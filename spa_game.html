<!-- Inizia la definizione del documento HTML, specificando che è un HTML5 -->
<!DOCTYPE html>
<!-- L'elemento radice del documento, con la lingua impostata su italiano ("it") -->
<html lang="it">
<!-- La sezione <head> contiene metadati e collegamenti a script e fogli di stile -->
<head>
    <!-- Specifica la codifica dei caratteri del documento come UTF-8, che supporta la maggior parte dei caratteri internazionali -->
    <meta charset="UTF-8">
    <!-- Imposta la viewport per garantire che il sito sia responsive e si adatti alla larghezza dello schermo del dispositivo -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Il titolo della pagina, che appare nella scheda del browser -->
    <title>Contenitore Trasparente</title>
    <!-- Inizia la sezione degli stili CSS, che definiscono l'aspetto della pagina -->
    <style>
        /* Reset base: un selettore universale (*) per applicare queste regole a tutti gli elementi */
        * {
            /* Rimuove tutti i margini esterni dagli elementi */
            margin: 0;
            /* Rimuove tutti i padding interni dagli elementi */
            padding: 0;
            /* Modifica il modello di box CSS in modo che padding e border siano inclusi nella larghezza e altezza totale dell'elemento */
            box-sizing: border-box;
        }

        /* Stili per gli elementi <html> e <body> */
        html, body {
            /* Imposta la larghezza al 100% della viewport (la finestra del browser) */
            width: 100%;
            /* Imposta l'altezza al 100% della viewport */
            height: 100%;
            /* Nasconde qualsiasi contenuto che superi le dimensioni del body, prevenendo lo scrolling */
            overflow: hidden;
        }

        /* Contenitore principale che avvolge tutta l'applicazione. Progettato per una risoluzione nativa di 1920x1080. */
        .main-container {
            /* Larghezza pari al 100% della larghezza della viewport (vw = viewport width) */
            width: 100vw;
            /* Altezza pari al 100% dell'altezza della viewport (vh = viewport height) */
            height: 100vh;
            /* Posizionamento assoluto rispetto al parente più vicino posizionato (in questo caso, il body) */
            position: absolute;
            /* Allinea il contenitore al bordo superiore */
            top: 0;
            /* Allinea il contenitore al bordo sinistro */
            left: 0;
            /* Sfondo trasparente, perché l'immagine di sfondo sarà in un altro div */
            background: transparent;
        }

        /* Questo contenitore è posizionato esattamente sopra il .main-container e conterrà l'immagine di sfondo. */
        .child-container {
            /* Occupa il 100% della larghezza del suo parente (.main-container) */
            width: 100%;
            /* Occupa il 100% dell'altezza del suo parente */
            height: 100%;
            /* Posizionamento assoluto per sovrapporsi perfettamente al parente */
            position: absolute;
            /* Allineato in alto */
            top: 0;
            /* Allineato a sinistra */
            left: 0;
            /* Sfondo trasparente per non coprire nulla che potrebbe esserci dietro (anche se non c'è) */
            background: transparent;
        }

        /* Stile per l'immagine di sfondo all'interno del .child-container */
        .child-container img {
            /* L'immagine occupa tutta la larghezza del contenitore */
            width: 100%;
            /* L'immagine occupa tutta l'altezza del contenitore */
            height: 100%;
            /* L'immagine viene stirata per riempire esattamente il contenitore, potenzialmente distorcendo le proporzioni. */
            object-fit: fill;
        }

        /* Questo è un livello scuro semitrasparente che si sovrappone all'immagine di sfondo per migliorare la leggibilità del testo. */
        .overlay-shadow {
            /* Occupa il 100% della larghezza */
            width: 100%;
            /* Occupa il 100% dell'altezza */
            height: 100%;
            /* Posizionamento assoluto per sovrapporsi all'immagine */
            position: absolute;
            /* Allineato in alto */
            top: 0;
            /* Allineato a sinistra */
            left: 0;
            /* Sfondo nero con una trasparenza del 75% (0.75 alpha) */
            background: rgba(0, 0, 0, 0.75);
        }

        /* Questo contenitore definisce la struttura principale della UI (header, main, footer) e si sovrappone all'ombra e allo sfondo. */
        .layout-container {
            /* Occupa il 100% della larghezza */
            width: 100%;
            /* Occupa il 100% dell'altezza */
            height: 100%;
            /* Posizionamento assoluto */
            position: absolute;
            /* Allineato in alto */
            top: 0;
            /* Allineato a sinistra */
            left: 0;
            /* Utilizza Flexbox per disporre i suoi figli (header, main, footer) */
            display: flex;
            /* I figli verranno impilati verticalmente (uno sopra l'altro) */
            flex-direction: column;
            /* Imposta un indice di stacking alto per assicurarsi che sia sopra l'ombra e l'immagine. */
            z-index: 10;
        }

        /* Stile per la sezione dell'header (la barra superiore) */
        .header-section {
            /* Occupa tutta la larghezza disponibile */
            width: 100%;
            /* Altezza fissa di 80 pixel */
            height: 80px;
            /* Sfondo nero con l'80% di opacità */
            background: rgba(0, 0, 0, 0.8);
            /* Bordo inferiore sottile e semitrasparente per separarlo dal contenuto principale */
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            /* Utilizza Flexbox per centrare il suo contenuto */
            display: flex;
            /* Allinea verticalmente il contenuto al centro */
            align-items: center;
            /* Allinea orizzontalmente il contenuto al centro */
            justify-content: center;
            /* Aggiunge padding orizzontale di 40px a sinistra e a destra */
            padding: 0 40px;
            /* Colore del testo bianco */
            color: white;
            /* Tipo di carattere standard */
            font-family: Arial, sans-serif;
        }

        /* Stile per la sezione principale del contenuto (l'area centrale) */
        .main-section {
            /* Occupa tutta la larghezza disponibile */
            width: 100%;
            /* 'flex: 1' fa in modo che questa sezione occupi tutto lo spazio verticale rimanente tra header e footer */
            flex: 1;
            /* Sfondo trasparente */
            background: transparent;
            /* Se il contenuto supera l'altezza, mostra una barra di scorrimento verticale */
            overflow-y: auto;
            /* Nessun padding interno */
            padding: 0;
            /* Colore del testo bianco */
            color: white;
            /* Tipo di carattere standard */
            font-family: Arial, sans-serif;
            /* Utilizza Flexbox per allineare il suo contenuto */
            display: flex;
            /* Allinea verticalmente il contenuto al centro (in questo caso, il menu-box) */
            align-items: center;
        }

        /* Stile per la sezione del footer (la barra inferiore) */
        .footer-section {
            /* Occupa tutta la larghezza disponibile */
            width: 100%;
            /* Altezza fissa di 60 pixel */
            height: 60px;
            /* Sfondo nero con il 50% di opacità */
            background: rgba(0, 0, 0, 0.5);
            /* Bordo superiore sottile e semitrasparente per separarlo dal contenuto principale */
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            /* Utilizza Flexbox per centrare il suo contenuto */
            display: flex;
            /* Allinea verticalmente il contenuto al centro */
            align-items: center;
            /* Allinea orizzontalmente il contenuto al centro */
            justify-content: center;
            /* Aggiunge padding orizzontale di 40px */
            padding: 0 40px;
            /* Colore del testo bianco */
            color: white;
            /* Tipo di carattere standard */
            font-family: Arial, sans-serif;
        }

        /* Stile per il titolo (elemento <h1>) all'interno dell'header */
        .header-section h1 {
            /* Imposta una famiglia di caratteri moderna e leggibile */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* La dimensione del carattere è relativa all'altezza della viewport (5% dell'altezza) */
            font-size: 5vh;
            /* Spessore del carattere grassetto */
            font-weight: 700;
            /* Colore del testo bianco */
            color: #ffffff;
            /* Aggiunge un'ombra al testo per migliorare la leggibilità */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            /* Spaziatura tra le lettere */
            letter-spacing: 1px;
            /* Rimuove il margine di default dell'h1 */
            margin: 0;
            /* Trasforma il testo in maiuscolo */
            text-transform: uppercase;
            /* Posizionamento relativo per permettere l'uso di pseudo-elementi posizionati assolutamente */
            position: relative;
        }

        /* Utilizza lo pseudo-elemento ::before per creare un effetto di "glow" (bagliore) per il titolo */
        .header-section h1::before {
            /* Il contenuto è una copia del testo dell'h1, preso dall'attributo 'data-text' */
            content: attr(data-text);
            /* Posizionamento assoluto rispetto all'h1 */
            position: absolute;
            /* Allineato in alto */
            top: 0;
            /* Allineato a sinistra */
            left: 0;
            /* Colore del testo molto trasparente */
            color: rgba(255, 255, 255, 0.1);
            /* Un'ombra di testo più ampia e sfocata per creare l'effetto di bagliore */
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            /* Mette questo pseudo-elemento dietro al testo principale dell'h1 */
            z-index: -1;
        }

        /* Stile per le sezioni della Single Page Application (SPA). Queste sono le diverse "schermate" del gioco. */
        .spa-section {
            /* Di default, tutte le sezioni sono nascoste */
            display: none;
            /* Occupano tutta la larghezza disponibile */
            width: 100%;
            /* Occupano tutta l'altezza disponibile */
            height: 100%;
        }

        /* Stile per la sezione SPA attualmente visibile */
        .spa-section.active {
            /* La sezione con la classe 'active' viene resa visibile. Usiamo flex per coerenza con il layout. */
            display: flex;
        }

        /* ================= STILI DEL MENU PRINCIPALE ================= */

        /* Stile per il box che contiene i pulsanti del menu */
        .menu-box {
            /* Margine sinistro del 3% per posizionarlo leggermente a destra */
            margin-left: 3%;
            /* Larghezza del 25% rispetto al suo contenitore (.main-section) */
            width: 25%;
            /* Altezza dell'80% rispetto al suo contenitore */
            height: 80%;
            /* Sfondo nero molto trasparente */
            background: rgba(0, 0, 0, 0.2);
            /* Bordo sottile e semitrasparente */
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Angoli arrotondati */
            border-radius: 12px;
            /* Padding interno di 10px */
            padding: 10px;
            /* Effetto "vetro smerigliato": sfoca ciò che si trova dietro al box */
            backdrop-filter: blur(5px);
        }

        /* Contenitore interno per i pulsanti del menu */
        .main-menu {
            /* Occupa tutta la larghezza del .menu-box */
            width: 100%;
            /* Occupa tutta l'altezza del .menu-box */
            height: 100%;
            /* Usa Flexbox per disporre i pulsanti */
            display: flex;
            /* Impila i pulsanti verticalmente */
            flex-direction: column;
            /* Distribuisce lo spazio uniformemente tra i pulsanti */
            justify-content: space-between;
            /* Centra i pulsanti orizzontalmente */
            align-items: center;
            /* Aggiunge uno spazio di 10px tra ogni pulsante */
            gap: 10px;
        }

        /* Stile base per tutti i pulsanti del menu */
        .menu-button {
            /* Larghezza del 95% del contenitore .main-menu */
            width: 95%;
            /* Calcola l'altezza: prende il 100% dell'altezza, sottrae 60px (per i gap) e divide per 7 (il numero di pulsanti) */
            height: calc((100% - 60px) / 7);
            /* Sfondo con un gradiente lineare dal blu chiaro al blu scuro */
            background: linear-gradient(135deg, #3498db, #2980b9);
            /* Bordo bianco quasi opaco */
            border: 1px solid #ecf0f1;
            /* Colore del testo bianco-grigiastro */
            color: #ecf0f1;
            /* Dimensione del carattere relativa all'altezza della viewport */
            font-size: 3vh;
            /* Testo in grassetto */
            font-weight: bold;
            /* Testo in maiuscolo */
            text-transform: uppercase;
            /* Il cursore diventa una manina quando si passa sopra */
            cursor: pointer;
            /* Transizione fluida di 0.3 secondi per tutte le proprietà animate (es. background, transform) */
            transition: all 0.3s ease;
            /* Usa Flexbox per centrare il testo nel pulsante */
            display: flex;
            /* Allinea il testo verticalmente al centro */
            align-items: center;
            /* Allinea il testo orizzontalmente al centro */
            justify-content: center;
            /* Ombra sul testo per migliorare la leggibilità */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            /* Ombra esterna per dare un effetto di profondità al pulsante */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            /* Angoli arrotondati */
            border-radius: 8px;
        }

        /* Stile del pulsante quando il mouse ci passa sopra (hover) */
        .menu-button:hover {
            /* Il gradiente di sfondo diventa leggermente più chiaro */
            background: linear-gradient(135deg, #5dade2, #3498db);
            /* Sposta il pulsante di 2 pixel verso l'alto per un effetto "sollevato" */
            transform: translateY(-2px);
            /* Aumenta l'ombra per accentuare l'effetto di sollevamento */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        /* Stile del pulsante mentre viene premuto (active) */
        .menu-button:active {
            /* Il gradiente di sfondo diventa più scuro */
            background: linear-gradient(135deg, #2471a3, #1f618d);
            /* Riporta il pulsante alla sua posizione originale */
            transform: translateY(0);
            /* Riduce l'ombra per dare un effetto "premuto" */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Stile speciale per il pulsante "Esci dal Gioco", che ha la classe aggiuntiva 'exit' */
        .menu-button.exit {
            /* Sfondo con gradiente rosso per indicare un'azione distruttiva/di uscita */
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        /* ================= STILI HALL OF FAME ================= */
        .hall-of-fame-box {
            width: 50%;
            height: 80%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
        }

        .hall-of-fame-list {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hall-of-fame-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 2.5vh;
        }

        .hall-of-fame-list li span:nth-child(1) {
            font-weight: bold;
            color: #f39c12;
            flex-basis: 10%;
        }

        .hall-of-fame-list li span:nth-child(2) {
            flex-basis: 60%;
            text-align: left;
        }

        .hall-of-fame-list li span:nth-child(3) {
            font-weight: bold;
            color: #f39c12;
            flex-basis: 30%;
            text-align: right;
        }

        /* Stile hover per il pulsante di uscita */
        .menu-button.exit:hover {
            /* Il gradiente diventa leggermente più chiaro al passaggio del mouse */
            background: linear-gradient(135deg, #ec7063, #e74c3c);
        }

        /* Stile active per il pulsante di uscita */
        .menu-button.exit:active {
            /* Il gradiente diventa più scuro quando premuto */
            background: linear-gradient(135deg, #a93226, #922b21);
        }

        /* ================= STILI DELLA SEZIONE CUTSCENE ================= */

        /* Stile per l'area principale del contenuto durante una cutscene. */
        .cutscene-main-section {
            /* Occupa tutta la larghezza */
            width: 100%;
            /* Occupa lo spazio verticale rimanente */
            flex: 1;
            /* Sfondo trasparente */
            background: transparent;
            /* Permette lo scrolling verticale se il contenuto è troppo lungo */
            overflow-y: auto;
            /* Nessun padding (verrà aggiunto dopo) */
            padding: 0;
            /* Colore del testo bianco */
            color: white;
            /* Font di default */
            font-family: Arial, sans-serif;
            /* Usa Flexbox per disporre le colonne (sinistra e destra) */
            display: flex;
            /* Allinea le colonne per occupare tutta l'altezza disponibile */
            align-items: stretch;
            /* Aggiunge 20px di padding su tutti i lati */
            padding: 20px;
            /* Crea uno spazio di 20px tra le due colonne */
            gap: 20px;
        }

        /* Stile per la colonna di sinistra, che contiene l'immagine della cutscene. */
        .left-column {
            /* Occupa il 60% della larghezza della .cutscene-main-section */
            width: 60%;
            /* Occupa il 100% dell'altezza */
            height: 100%;
            /* Usa Flexbox per centrare il suo contenuto (l'image-container) */
            display: flex;
            /* Dispone gli elementi interni in colonna (anche se ce n'è solo uno) */
            flex-direction: column;
            /* Centra l'image-container orizzontalmente */
            align-items: center;
            /* Centra l'image-container verticalmente */
            justify-content: center;
        }

        /* Contenitore per l'immagine della cutscene. È progettato per essere un quadrato perfetto. */
        .image-container {
            /* Occupa il 90% della larghezza della colonna sinistra */
            width: 90%;
            /* Mantiene un rapporto d'aspetto di 1:1, rendendolo un quadrato */
            aspect-ratio: 1;
            /* La larghezza massima non può superare l'80% dell'altezza della viewport */
            max-width: 80vh;
            /* Sfondo semitrasparente come fallback */
            background: rgba(0, 0, 0, 0.2);
            /* Bordo sottile e semitrasparente */
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Angoli arrotondati */
            border-radius: 12px;
            /* Effetto vetro smerigliato */
            backdrop-filter: blur(5px);
            /* Usa Flexbox per centrare l'immagine o il placeholder all'interno */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Nasconde qualsiasi parte dell'immagine che esce dal contenitore */
            overflow: hidden;
            /* Posizionamento relativo (utile per eventuali overlay futuri) */
            position: relative;
            /* Impedisce al contenitore di restringersi se lo spazio è poco */
            flex-shrink: 0;
        }

        /* Stile per l'immagine vera e propria dentro l'image-container */
        .image-container img {
            width: 100%;
            height: 100%;
            /* 'cover' scala l'immagine per coprire l'intero contenitore mantenendo le proporzioni, tagliando le parti in eccesso se necessario. */
            object-fit: cover;
            /* Centra l'immagine all'interno del contenitore */
            object-position: center;
            /* Angoli arrotondati per l'immagine stessa */
            border-radius: 12px;
        }

        /* Stile per il testo segnaposto mostrato quando non c'è un'immagine. */
        .image-placeholder {
            /* Colore del testo bianco semitrasparente */
            color: rgba(255, 255, 255, 0.7);
            /* Dimensione del font relativa all'altezza della viewport */
            font-size: 2vh;
            /* Testo centrato */
            text-align: center;
            /* Stile corsivo */
            font-style: italic;
        }

        /* Stile per la colonna di destra, che contiene il testo narrativo e il pulsante "Continua". */
        .right-column {
            /* Occupa il 40% della larghezza della .cutscene-main-section */
            width: 40%;
            height: 100%;
            /* Usa Flexbox per disporre i suoi figli (narrativa e pulsante) */
            display: flex;
            /* Impila gli elementi verticalmente */
            flex-direction: column;
            /* Crea uno spazio di 15px tra la sezione narrativa e quella del pulsante */
            gap: 15px;
        }

        /* Stile per il box che contiene il testo narrativo. */
        .narrative-section {
            /* 'flex: 1' fa sì che questo box occupi tutto lo spazio verticale disponibile nella colonna destra */
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            /* Padding interno di 20px */
            padding: 20px;
            backdrop-filter: blur(5px);
            /* Mostra una barra di scorrimento verticale se il testo è troppo lungo */
            overflow-y: auto;
        }

        /* Stile del paragrafo di testo narrativo. */
        .narrative-text {
            color: #ffffff;
            font-size: 2.2vh;
            /* Interlinea, per una migliore leggibilità */
            line-height: 1.6;
            /* Testo giustificato per un aspetto più pulito */
            text-align: justify;
            /* Ombra sul testo */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Contenitore per il pulsante "Continua". */
        .button-section {
            /* Altezza fissa di 80px */
            height: 80px;
            /* Usa Flexbox per centrare il pulsante al suo interno */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Stile per il pulsante "Continua". È molto simile al .menu-button. */
        .continue-button {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: 1px solid #ecf0f1;
            color: #ecf0f1;
            font-size: 3vh;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            /* Aumenta la spaziatura tra le lettere per un look più "cinematografico" */
            letter-spacing: 2px;
        }

        /* Effetti hover e active identici a .menu-button */
        .continue-button:hover {
            background: linear-gradient(135deg, #5dade2, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .continue-button:active {
            background: linear-gradient(135deg, #2471a3, #1f618d);
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Stili per personalizzare la barra di scorrimento nel box narrativo (funziona solo su browser basati su WebKit come Chrome/Safari). */
        /* La barra di scorrimento stessa */
        .narrative-section::-webkit-scrollbar {
            width: 8px;
        }

        /* La traccia (lo sfondo) della barra di scorrimento */
        .narrative-section::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        /* Il "pollice" (la parte che si trascina) della barra di scorrimento */
        .narrative-section::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        /* Il "pollice" quando ci si passa sopra con il mouse */
        .narrative-section::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* ================= STILI DELL'INTERFACCIA DI GIOCO (GAME UI) ================= */

        /* Stile per l'area principale del contenuto dell'interfaccia di gioco. */
        .game-ui-main-section {
            width: 100%;
            /* Occupa il 90% dell'altezza del suo contenitore (.layout-container) */
            height: 90%;
            background: transparent;
            overflow-y: auto;
            padding: 0;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            align-items: stretch;
            /* Usa un padding e un gap relativi alla dimensione del contenitore per scalare meglio */
            padding: 1%;
            gap: 1%;
        }

        /* Stile per l'header specifico della UI di gioco. */
        .game-ui-header-section {
            width: 100%;
            /* Occupa il 5% dell'altezza */
            height: 5%;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 2%;
            color: white;
            font-family: Arial, sans-serif;
        }

        /* Stile per il footer specifico della UI di gioco. */
        .game-ui-footer-section {
            width: 100%;
             /* Occupa il 5% dell'altezza */
            height: 5%;
            background: rgba(0, 0, 0, 0.5);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            /* Distribuisce gli elementi (sinistra, centro, destra) lungo l'asse orizzontale */
            justify-content: space-between;
            padding: 0 2%;
            color: white;
            font-family: Arial, sans-serif;
        }

        /* Contenitore per gli elementi a sinistra nel footer (es. pulsante "Back"). */
        .footer-left {
            display: flex;
            align-items: center;
        }

        /* Stile per il pulsante "Back" e altri pulsanti simili nel footer. */
        .back-button {
            background: linear-gradient(135deg, #34495e, #2c3e50); /* Gradiente grigio-blu scuro */
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ecf0f1;
            font-size: 1.4vh; /* Dimensione del font più piccola */
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 1vh 2vh; /* Padding relativo alla viewport height */
            border-radius: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .back-button:hover {
            background: linear-gradient(135deg, #5d6d7e, #34495e);
            transform: translateY(-1px); /* Sollevamento più leggero */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .back-button:active {
            background: linear-gradient(135deg, #273746, #1b2631);
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Contenitore per gli elementi al centro nel footer. */
        .footer-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Contenitore per gli elementi a destra nel footer (es. controllo volume). */
        .footer-right {
            display: flex;
            align-items: center;
            gap: 1vh; /* Spazio tra icona e slider */
        }

        /* Contenitore per il controllo del volume. */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 1vh;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5vh 1vh;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(3px);
        }

        /* Icona del volume (un elemento <span> con un'emoji). */
        .volume-icon {
            font-size: 2vh;
            color: #f39c12; /* Colore arancione */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .volume-icon:hover {
            color: #e67e22; /* Arancione più scuro */
            transform: scale(1.1); /* Leggero ingrandimento */
        }

        /* Stile personalizzato per lo slider del volume (<input type="range">). */
        .volume-slider {
            width: 8vh; /* Larghezza relativa */
            height: 0.6vh; /* Altezza relativa */
            background: rgba(255, 255, 255, 0.2); /* Sfondo della traccia */
            border-radius: 3px;
            outline: none; /* Rimuove il bordo di focus di default */
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-appearance: none; /* Rimuove lo stile di default del browser (per Chrome/Safari) */
            appearance: none; /* Rimuove lo stile di default del browser (standard) */
        }

        /* Stile per il "pollice" (la maniglia) dello slider per browser WebKit (Chrome/Safari). */
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.8vh;
            height: 1.8vh;
            background: #f39c12;
            border-radius: 50%; /* Cerchio perfetto */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            margin-top: -0.6vh; /* Trucco per centrare verticalmente il pollice sulla traccia */
        }

        .volume-slider::-webkit-slider-thumb:hover {
            background: #e67e22;
            transform: scale(1.2);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        /* Stile per il "pollice" dello slider per Firefox. */
        .volume-slider::-moz-range-thumb {
            width: 1.8vh;
            height: 1.8vh;
            background: #f39c12;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .volume-slider::-moz-range-thumb:hover {
            background: #e67e22;
            transform: scale(1.2);
        }

        /* Stile per la traccia dello slider per WebKit, per mostrare il progresso. */
        .volume-slider::-webkit-slider-runnable-track {
            height: 0.6vh;
            /* Usa un gradiente che colora la traccia fino alla percentuale definita dalla variabile CSS --volume-percent */
            background: linear-gradient(to right, #f39c12 0%, #f39c12 var(--volume-percent, 50%), rgba(255, 255, 255, 0.2) var(--volume-percent, 50%), rgba(255, 255, 255, 0.2) 100%);
            border-radius: 3px;
        }

        /* Stile per la traccia dello slider per Firefox. */
        .volume-slider::-moz-range-track {
            height: 0.6vh;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            border: none;
        }

        /* Stile per la barra di progresso in Firefox. */
        .volume-slider::-moz-range-progress {
            height: 0.6vh;
            background: #f39c12;
            border-radius: 3px;
        }

        /* Stile per il titolo nell'header della UI di gioco. */
        .game-ui-header-section h1 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 3vh; /* Più piccolo rispetto al menu principale */
            font-weight: 700;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
            margin: 0;
            text-transform: uppercase;
            position: relative;
        }

        /* Effetto glow per il titolo (identico a quello principale). */
        .game-ui-header-section h1::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            color: rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            z-index: -1;
        }

        /* Colonna sinistra della UI di gioco (contiene l'immagine). */
        .left-column-game {
            width: 40%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        /* Contenitore dell'immagine nella UI di gioco. */
        .image-container-game {
            width: 90%;
            max-width: 80vh;
            max-height: 80vh;
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3%; /* Angoli meno arrotondati */
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
        }

        /* Immagine nella UI di gioco. */
        .image-container-game img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            border-radius: 3%;
        }

        /* Box delle statistiche sotto l'immagine di gioco */
        .stats-box-game {
            width: 90%;
            margin-top: 2%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3%;
            padding: 3%;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .stats-label {
            color: #ffffff;
            font-size: 1.8vh;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .stats-value {
            color: #f39c12;
            font-size: 2.5vh;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Colonna destra della UI di gioco (contiene risorse, pulsanti e testo). */
        .right-column-game {
            width: 60%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 2%; /* Spazio tra la sezione risorse e il contenitore inferiore */
        }

        /* Sezione che mostra le risorse del giocatore (oro, legno, etc.). */
        .resources-section {
            height: 60%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3%;
            padding: 3%;
            backdrop-filter: blur(5px);
            /* Usa CSS Grid per disporre le risorse in una griglia */
            display: grid;
            /* 4 colonne di larghezza uguale */
            grid-template-columns: repeat(4, 1fr);
            /* 4 righe di altezza uguale per un totale di 16 box */
            grid-template-rows: repeat(4, 1fr);
            /* Spazio tra le celle della griglia */
            gap: 2%;
        }

        /* Stile per un singolo elemento risorsa. */
        .resource-item {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            gap: 3%;
            padding: 2%;
            background: rgba(255, 255, 255, 0.05); /* Sfondo leggermente visibile */
            border-radius: 8%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Icona della risorsa. */
        .resource-icon {
            width: 35%;
            aspect-ratio: 1; /* Mantiene l'icona quadrata */
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Impedisce all'icona di rimpicciolirsi */
            font-size: 2vh; /* Dimensione per l'emoji di fallback */
        }

        /* Stile per l'icona quando viene usata un'emoji come fallback. */
        .resource-icon.placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-weight: bold;
        }

        /* Immagine dell'icona. */
        .resource-icon img {
            width: 100%;
            height: 100%;
            object-fit: fill; /* Adatta l'immagine per riempire l'icona */
            border-radius: 10%;
        }

        /* Contenitore per le informazioni della risorsa (nome e valore). */
        .resource-info {
            flex: 1; /* Occupa lo spazio rimanente */
            display: flex;
            flex-direction: column;
            gap: 5%;
            min-width: 0; /* Impedisce al testo di "spingere" fuori dal contenitore */
        }

        /* Etichetta (nome) della risorsa. */
        .resource-label {
            color: #ffffff;
            font-size: 1.8vh;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            white-space: nowrap; /* Impedisce al testo di andare a capo */
            overflow: hidden; /* Nasconde il testo in eccesso */
            text-overflow: ellipsis; /* Aggiunge "..." se il testo è troppo lungo */
        }

        /* Valore numerico della risorsa. */
        .resource-value {
            color: #f39c12; /* Arancione, per risaltare */
            font-size: 2.5vh;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Contenitore inferiore, che contiene i pulsanti di azione e il testo narrativo. */
        .bottom-container {
            height: 38%;
            display: flex;
            gap: 2%;
        }

        /* Sezione per i pulsanti di azione. */
        .buttons-section {
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3%;
            padding: 3%;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Distribuisce i pulsanti uniformemente */
            gap: 3%;
        }

        /* Stile per i pulsanti di azione rettangolari. */
        .action-button {
            width: 100%;
            height: 22%; /* Altezza relativa per adattarsi al contenitore */
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: 1px solid #ecf0f1;
            color: #ecf0f1;
            font-size: 2.2vh;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border-radius: 5%;
            letter-spacing: 1px;
        }

        .action-button:hover {
            background: linear-gradient(135deg, #5dade2, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .action-button:active {
            background: linear-gradient(135deg, #2471a3, #1f618d);
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Stile per un pulsante di azione disabilitato. */
        .action-button:disabled {
            background: linear-gradient(135deg, #808080, #696969); /* Grigio */
            color: #b0b0b0; /* Testo grigio chiaro */
            cursor: not-allowed; /* Cursore "non permesso" */
            transform: none; /* Rimuove l'effetto di sollevamento */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border-color: #707070;
        }

        /* Classi 'success' e 'danger' per categorizzare i pulsanti (attualmente non cambiano il colore). */
        .action-button.success {
            /* Qui si potrebbero aggiungere stili specifici, come un'icona di spunta. */
        }

        .action-button.danger {
            /* Qui si potrebbero aggiungere stili specifici, come un'icona di avvertimento. */
        }

        /* Sezione per il testo narrativo all'interno della UI di gioco. */
        .narrative-section-game {
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3%;
            padding: 3%;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Permette lo scrolling se il testo è troppo */
        }

        /* Titolo del box narrativo (es. "Guida"). */
        .narrative-title {
            color: #ffffff;
            font-size: 2.2vh;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            margin-bottom: 3%;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Linea di separazione */
            padding-bottom: 2%;
        }

        /* Contenuto del testo narrativo. */
        .narrative-content {
            color: rgba(255, 255, 255, 0.9); /* Testo leggermente trasparente per un look più morbido */
            font-size: 2.4vh;
            line-height: 1.6;
            text-align: justify;
            flex: 1; /* Occupa lo spazio rimanente */
            overflow-y: auto; /* Scrollbar interna se necessario */
            padding: 2% 3%;
            transition: all 0.3s ease; /* Transizione fluida quando il testo cambia */
        }

        /* Stili per la scrollbar personalizzata (identica a quella della cutscene). */
        .narrative-content::-webkit-scrollbar {
            width: 8px;
        }

        .narrative-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .narrative-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .narrative-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* ================= STILI DEL SISTEMA DI MODALI (POP-UP) ================= */

        /* Stile per l'overlay di sfondo che appare quando un modale è attivo. */
        .modal-overlay {
            /* Posizionamento fisso per coprire l'intera finestra, anche se si scorre la pagina. */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Sfondo nero molto scuro e quasi opaco per focalizzare l'attenzione sul modale. */
            background: rgba(0, 0, 0, 0.9);
            /* Di default, l'overlay è nascosto. Verrà mostrato da JavaScript aggiungendo la classe 'active'. */
            display: none;
            /* Usa Flexbox per centrare il contenitore del modale al suo interno. */
            align-items: center;
            justify-content: center;
            /* z-index molto alto per assicurarsi che sia sopra a tutto il resto. */
            z-index: 9999;
            /* Inizia con opacità 0 per creare un effetto di dissolvenza in entrata. */
            opacity: 0;
            /* Anima la proprietà 'opacity' per 0.3 secondi. */
            transition: opacity 0.3s ease;
        }

        /* Stile per l'overlay quando è attivo. */
        .modal-overlay.active {
            /* Usa flex per centrare il suo contenuto. */
            display: flex;
            /* Rende l'overlay completamente visibile. */
            opacity: 1;
        }

        /* Stile per il contenitore principale del modale (la finestra pop-up). */
        .modal-container {
            /* Sfondo con gradiente scuro. */
            background: linear-gradient(135deg, #2c3e50, #34495e);
            /* Bordo semitrasparente. */
            border: 2px solid rgba(255, 255, 255, 0.3);
            /* Angoli molto arrotondati. */
            border-radius: 20px;
            /* Padding interno generoso. */
            padding: 40px;
            /* Larghezza massima e minima per mantenere proporzioni leggibili. */
            max-width: 600px;
            min-width: 400px;
            /* Ombra esterna molto pronunciata per dare profondità. */
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            /* Effetto vetro smerigliato. */
            backdrop-filter: blur(10px);
            /* Inizia leggermente rimpicciolito per un effetto di "pop-up". */
            transform: scale(0.8);
            /* Anima la proprietà 'transform' per 0.3 secondi. */
            transition: transform 0.3s ease;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Usa Flexbox per disporre il contenuto del modale. */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Quando il modale è attivo, il suo contenitore torna alla scala normale (100%). */
        .modal-overlay.active .modal-container {
            transform: scale(1);
        }

        /* Stile per il contenitore dell'immagine opzionale nel modale. */
        .modal-image-container {
            width: 30%;
            aspect-ratio: 1 / 1; /* Immagine quadrata */
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            /* Nascosto di default, viene mostrato da JavaScript se un'immagine è fornita. */
            display: none;
            flex-shrink: 0;
        }

        .modal-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Titolo del modale. */
        .modal-title {
            font-size: 3vh;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #ecf0f1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Messaggio di testo del modale. */
        .modal-message {
            font-size: 2.4vh;
            line-height: 1.6;
            text-align: center;
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.9);
            /* Permette di usare i ritorni a capo (\n) nel testo per formattare il messaggio. */
            white-space: pre-line;
        }

        /* Contenitore per il campo di input, se presente. */
        .modal-input-container {
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
        }

        /* Stile per il campo di input di testo. */
        .modal-input {
            width: 80%;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #ffffff;
            font-size: 2.2vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            transition: all 0.3s ease;
            /* Ombra interna per dare profondità. */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* Stile del campo di input quando è in focus (selezionato). */
        .modal-input:focus {
            outline: none;
            border-color: #5dade2; /* Colore blu per indicare il focus */
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5); /* Bagliore esterno */
        }

        /* Stile per il testo segnaposto (placeholder) dell'input. */
        .modal-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Contenitore per i pulsanti del modale. */
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        /* Stile base per tutti i pulsanti del modale. */
        .modal-button {
            padding: 15px 30px;
            border: 2px solid transparent; /* Bordo trasparente per non spostare il layout al cambio di colore */
            border-radius: 10px;
            font-size: 2.2vh;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            letter-spacing: 1px;
        }

        /* Stile per il pulsante di conferma (es. "OK", "Sì"). */
        .modal-button.confirm {
            background: linear-gradient(135deg, #27ae60, #229954); /* Gradiente verde */
            border-color: #58d68d;
            color: #ffffff;
        }

        .modal-button.confirm:hover {
            background: linear-gradient(135deg, #58d68d, #27ae60);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(39, 174, 96, 0.5); /* Ombra colorata */
        }

        .modal-button.confirm:active {
            background: linear-gradient(135deg, #1e8449, #196f3d);
            transform: translateY(0);
        }

        /* Stile per il pulsante di annullamento (es. "Annulla", "No"). */
        .modal-button.cancel {
            background: linear-gradient(135deg, #e74c3c, #c0392b); /* Gradiente rosso */
            border-color: #ec7063;
            color: #ffffff;
        }

        .modal-button.cancel:hover {
            background: linear-gradient(135deg, #ec7063, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.5); /* Ombra colorata */
        }

        .modal-button.cancel:active {
            background: linear-gradient(135deg, #a93226, #922b21);
            transform: translateY(0);
        }

        /* Stile per un pulsante generico informativo (es. "Continua"). */
        .modal-button.info {
            background: linear-gradient(135deg, #3498db, #2980b9); /* Gradiente blu */
            border-color: #5dade2;
            color: #ffffff;
        }

        .modal-button.info:hover {
            background: linear-gradient(135deg, #5dade2, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.5); /* Ombra colorata */
        }

        .modal-button.info:active {
            background: linear-gradient(135deg, #2471a3, #1f618d);
            transform: translateY(0);
        }

        /* Aggiunge un'icona (emoji) prima del titolo a seconda del tipo di modale. */
        .modal-title.confirm-title::before {
            content: "⚠️ ";
            font-size: 3.5vh;
            margin-right: 10px;
        }

        .modal-title.info-title::before {
            content: "ℹ️ ";
            font-size: 3.5vh;
            margin-right: 10px;
        }

        .modal-title.success-title::before {
            content: "✅ ";
            font-size: 3.5vh;
            margin-right: 10px;
        }

        .modal-title.download-title::before {
            content: "💾 ";
            font-size: 3.5vh;
            margin-right: 10px;
        }

        /* Stili responsivi per i modali su schermi piccoli (es. tablet in verticale, smartphone). */
        /* Questa regola si applica solo se la larghezza dello schermo è 768px o inferiore. */
        @media (max-width: 768px) {
            /* Rende il modale più largo per adattarsi meglio allo schermo. */
            .modal-container {
                max-width: 90vw;
                min-width: 300px;
                padding: 30px 20px;
            }
            
            /* Impila i pulsanti del modale verticalmente invece che orizzontalmente. */
            .modal-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            /* Fa in modo che i pulsanti occupino tutta la larghezza del modale. */
            .modal-button {
                width: 100%;
                min-width: auto;
            }
        }

        /* ================= MEDIA QUERIES PER SCALABILITÀ ================= */
        /* L'approccio qui è di definire un layout fisso (1920x1080) e poi scalarlo con 'transform: scale()' */
        /* per adattarsi perfettamente a diverse risoluzioni standard con aspect ratio 16:9. */
        /* Questo garantisce che l'interfaccia appaia identica, solo più grande o più piccola. */
        
        /* 8K UHD - 7680x4320 - Fattore di scala 4 (7680 / 1920 = 4) */
        @media screen and (width: 7680px) and (height: 4320px) {
            .main-container { transform: scale(4); }

        }

        /* 5K - 5120x2880 - Fattore di scala ~2.66 (5120 / 1920) */
        @media screen and (width: 5120px) and (height: 2880px) {
            .main-container { transform: scale(2.66); }

        }

        /* 4K UHD - 3840x2160 - Fattore di scala 2 (3840 / 1920) */
        @media screen and (width: 3840px) and (height: 2160px) {
            .main-container { transform: scale(2); }

        }

        /* QHD+ - 3200x1800 - Fattore di scala ~1.66 (3200 / 1920) */
        @media screen and (width: 3200px) and (height: 1800px) {
            .main-container { transform: scale(1.66); }

        }

        /* QHD - 2560x1440 - Fattore di scala ~1.33 (2560 / 1920) */
        @media screen and (width: 2560px) and (height: 1440px) {
            .main-container { transform: scale(1.33); }

        }

        /* Custom - 2048x1152 - Fattore di scala ~1.06 (2048 / 1920) */
        @media screen and (width: 2048px) and (height: 1152px) {
            .main-container { transform: scale(1.06); }

        }

        /* Full HD - 1920x1080 - Layout nativo, nessuna scala. */
        @media screen and (width: 1920px) and (height: 1080px) {
            .main-container { transform: scale(1); }

        }

        /* HD+ - 1600x900 - Fattore di scala ~0.83 (1600 / 1920) */
        @media screen and (width: 1600px) and (height: 900px) {
            .main-container { transform: scale(0.83); }

        }

        /* FWXGA - 1366x768 - Fattore di scala ~0.71 (1366 / 1920) */
        @media screen and (width: 1366px) and (height: 768px) {
            .main-container { transform: scale(0.71); }

        }

        /* HD - 1280x720 - Fattore di scala ~0.66 (1280 / 1920) */
        @media screen and (width: 1280px) and (height: 720px) {
            .main-container { transform: scale(0.66); }

        }

        /* WSVGA - 1024x576 - Fattore di scala ~0.53 (1024 / 1920) */
        @media screen and (width: 1024px) and (height: 576px) {
            .main-container { transform: scale(0.53); }

        }

        /* qHD - 960x540 - Fattore di scala 0.5 (960 / 1920) */
        @media screen and (width: 960px) and (height: 540px) {
            .main-container { transform: scale(0.5); }

        }

        /* FWVGA - 854x480 - Fattore di scala ~0.44 (854 / 1920) */
        @media screen and (width: 854px) and (height: 480px) {
            .main-container { transform: scale(0.44); }

        }

        /* nHD - 640x360 - Fattore di scala ~0.33 (640 / 1920) */
        @media screen and (width: 640px) and (height: 360px) {
            .main-container { transform: scale(0.33); }

        }

        /* Gestione per schermi con aspect ratio più "stretti" di 16:9 (es. 4:3, 5:4, monitor verticali). */
        /* Questa regola si applica se la larghezza è meno di 16/9 volte l'altezza. */
        @media screen and (max-aspect-ratio: 16/9) {
            /* Il contenitore principale viene ridimensionato per mantenere l'aspect ratio di 16:9 (letterboxing). */
            .main-container {
                width: 100vw;
                /* L'altezza viene calcolata in base alla larghezza per forzare il 16:9. */
                height: calc(100vw * 9 / 16);
                /* Posizionato al 50% dall'alto. */
                top: 50%;
                left: 0;
                /* Traslato verso l'alto della metà della sua altezza per essere centrato verticalmente. */
                transform: translateY(-50%);
            }
            
            /* Il body viene reso nero per riempire le bande nere sopra e sotto (letterbox). */
            body {
                background: #000;
                overflow: hidden;
            }
        }
    </style>
</head>
<!-- Il tag <body> contiene tutto il contenuto visibile della pagina web. -->
<body>
    <!-- Questo è il contenitore principale che scala l'intera interfaccia. -->
    <div class="main-container">
        
        <!-- Questo div contiene l'immagine di sfondo principale dell'applicazione. -->
        <div class="child-container">
            <img src="main_menu_bg.png" alt="Immagine di sfondo">
        </div>
        
        <!-- Questo div crea un'ombra scura sopra l'immagine di sfondo per migliorare la leggibilità del testo. -->
        <div class="overlay-shadow"></div>
        
        <!-- ================= SEZIONE MENU PRINCIPALE ================= -->
        <!-- Questa è la prima "schermata" (sezione SPA) che l'utente vede. Ha la classe 'active' per essere visibile al caricamento. -->
        <div id="main-menu-section" class="spa-section active">
            <!-- Utilizza la struttura a 3 righe (header, main, footer) definita in CSS. -->
            <div class="layout-container">
                <!-- Header della sezione. -->
                <header class="header-section">
                    <!-- Titolo principale. L'attributo 'data-text' è usato dal CSS per creare l'effetto di bagliore. -->
                    <h1 data-text="HEADER - TITOLO DELLA PAGINA">HEADER - TITOLO DELLA PAGINA</h1>
                </header>
                
                <!-- Area principale del contenuto. -->
                <main class="main-section">
                    <!-- Il box semitrasparente che contiene i pulsanti del menu. -->
                    <div class="menu-box">
                        <!-- Il contenitore flex che allinea i pulsanti. -->
                        <div class="main-menu">
                            <!-- Ogni pulsante chiama una funzione JavaScript diversa quando cliccato (onclick). -->
                            <button class="menu-button" onclick="startNewGame()">Nuova Partita</button>
                            <button class="menu-button" onclick="loadGame()">Continua Partita</button>
                            <button class="menu-button" onclick="showImportSavegame()">Import Savegame</button>
                            <button class="menu-button" onclick="showHallOfFame()">Hall of Fame</button>
                            <button class="menu-button" onclick="showCredits()">Crediti</button>
                            <button class="menu-button" onclick="showTutorial()">Tutorial</button>
                            <!-- Questo pulsante ha una classe extra 'exit' per dargli uno stile diverso (rosso). -->
                            <button class="menu-button exit" onclick="exitGame()">Esci dal Gioco</button>
                        </div>
                    </div>
                </main>
                
                <!-- Footer della sezione (attualmente vuoto). -->
                <footer class="footer-section">
                    <div class="footer-left"></div>
                    <div class="footer-center"></div>
                    <div class="footer-right">
                        <!-- Controllo del volume. -->
                        <div class="volume-control">
                            <span class="volume-icon" onclick="toggleMute()">🔊</span>
                            <input type="range"
                                   id="volume-slider-main"
                                   class="volume-slider"
                                   min="0"
                                   max="100"
                                   value="0"
                                   oninput="changeVolume(this.value)">
                        </div>
                    </div>
                </footer>
            </div>
        </div>

        <!-- ================= SEZIONE HALL OF FAME ================= -->
        <div id="hall-of-fame-section" class="spa-section">
            <div class="layout-container">
                <header class="header-section">
                    <h1 data-text="HALL OF FAME">HALL OF FAME</h1>
                </header>
                <main class="main-section" style="justify-content: center;">
                    <div class="hall-of-fame-box">
                        <ol class="hall-of-fame-list">
                            <li><span>1.</span><span>Alessandro "Il Grande"</span><span>1,250,000</span></li>
                            <li><span>2.</span><span>Beatrice "La Saggia"</span><span>1,180,000</span></li>
                            <li><span>3.</span><span>Carlo "Il Conquistatore"</span><span>1,150,000</span></li>
                            <li><span>4.</span><span>Diana "La Cacciatrice"</span><span>1,100,000</span></li>
                            <li><span>5.</span><span>Edoardo "Il Costruttore"</span><span>1,050,000</span></li>
                            <li><span>6.</span><span>Francesca "La Mercante"</span><span>980,000</span></li>
                            <li><span>7.</span><span>Giovanni "Il Navigatore"</span><span>950,000</span></li>
                            <li><span>8.</span><span>Isabella "La Regina"</span><span>920,000</span></li>
                            <li><span>9.</span><span>Leonardo "L'Inventore"</span><span>890,000</span></li>
                            <li><span>10.</span><span>Marco "Il Viaggiatore"</span><span>850,000</span></li>
                            <li><span>11.</span><span>Nicoletta "La Tessitrice"</span><span>820,000</span></li>
                            <li><span>12.</span><span>Orlando "Il Paladino"</span><span>790,000</span></li>
                            <li><span>13.</span><span>Paola "La Guaritrice"</span><span>760,000</span></li>
                            <li><span>14.</span><span>Riccardo "Cuor di Leone"</span><span>730,000</span></li>
                            <li><span>15.</span><span>Sofia "La Studiosa"</span><span>700,000</span></li>
                            <li><span>16.</span><span>Tommaso "Il Contadino"</span><span>670,000</span></li>
                            <li><span>17.</span><span>Valentina "La Diplomatica"</span><span>640,000</span></li>
                            <li><span>18.</span><span>Zaccaria "Il Minatore"</span><span>610,000</span></li>
                            <li><span>19.</span><span>Laura "La Poetessa"</span><span>580,000</span></li>
                            <li><span>20.</span><span>Vittorio "Il Vincitore"</span><span>550,000</span></li>
                        </ol>
                    </div>
                </main>
                <footer class="footer-section">
                     <div class="footer-left">
                        <button class="back-button" onclick="showSection('main-menu-section')">← BACK TO MAIN MENU</button>
                    </div>
                    <div class="footer-center"></div>
                    <div class="footer-right">
                        <div class="volume-control">
                            <span class="volume-icon" onclick="toggleMute()">🔊</span>
                            <input type="range"
                                   id="volume-slider-hof"
                                   class="volume-slider"
                                   min="0"
                                   max="100"
                                   value="0"
                                   oninput="changeVolume(this.value)">
                        </div>
                    </div>
                </footer>
            </div>
        </div>

        <!-- ================= SEZIONE CUTSCENE ================= -->
        <!-- Questa sezione SPA è inizialmente nascosta e viene mostrata per le scene narrative. -->
        <div id="cutscene-section" class="spa-section">
            <div class="layout-container">
                <header class="header-section">
                    <!-- Il titolo della cutscene. Verrà modificato da JavaScript. -->
                    <h1 id="cutscene-title" data-text="L'INIZIO DELL'AVVENTURA">L'INIZIO DELL'AVVENTURA</h1>
                </header>
                
                <!-- L'area principale della cutscene, divisa in due colonne. -->
                <main class="cutscene-main-section">
                    <!-- Colonna sinistra per l'immagine. -->
                    <div class="left-column">
                        <div class="image-container">
                            <!-- Questo div funge da segnaposto per l'immagine, che verrà caricata da JavaScript. -->
                            <div class="image-placeholder">Immagine della cutscene qui</div>
                        </div>
                    </div>

                    <!-- Colonna destra per il testo e il pulsante. -->
                    <div class="right-column">
                        <!-- Box per il testo narrativo. -->
                        <div class="narrative-section">
                            <!-- Il testo della cutscene. Verrà popolato da JavaScript. -->
                            <div class="narrative-text" id="cutscene-narrative-content">
                                Era una notte buia e tempestosa quando il nostro eroe iniziò il suo viaggio. Le stelle erano nascoste dalle nuvole cariche di pioggia, e solo il bagliore intermittente dei fulmini illuminava il sentiero tortuoso che si estendeva davanti a lui.
                                <br><br>
                                Con il cuore pieno di determinazione e la mente concentrata sull'obiettivo, prese il primo passo verso un destino che avrebbe cambiato per sempre il corso della sua vita. Non sapeva ancora quali sfide lo attendevano, ma era pronto ad affrontare qualsiasi ostacolo.
                                <br><br>
                                Il vento ululava tra gli alberi spogli, creando una sinfonia inquietante che accompagnava ogni suo passo. Ad ogni lampo, ombre danzanti sembravano prendere vita, ma la sua determinazione non vacillava mai.
                            </div>
                        </div>

                        <!-- Sezione per il pulsante "Continua". -->
                        <div class="button-section">
                            <button class="continue-button" onclick="continueCutscene()">CONTINUA</button>
                        </div>
                    </div>
                </main>
                
                <footer class="footer-section">
                </footer>
            </div>
        </div>

        <!-- ================= SEZIONE INTERFACCIA DI GIOCO (GAME UI) ================= -->
        <!-- Questa è la schermata principale del gioco, inizialmente nascosta. -->
        <div id="game-ui-section" class="spa-section">
            <div class="layout-container">
                <!-- Header della UI di gioco. -->
                <header class="game-ui-header-section">
                    <h1 id="game-ui-title" data-text="L'INIZIO DELL'AVVENTURA">L'INIZIO DELL'AVVENTURA</h1>
                </header>
                
                <!-- Area principale della UI di gioco, divisa in due colonne. -->
                <main class="game-ui-main-section">
                    <!-- Colonna sinistra per l'immagine della location. -->
                    <div class="left-column-game">
                        <div class="image-container-game">
                            <div class="image-placeholder">Immagine della cutscene qui</div>
                        </div>
                        <div class="stats-box-game">
                            <div class="stats-item">
                                <span class="stats-label">Anni Passati</span>
                                <span class="stats-value" id="years-passed-value">0</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Punteggio</span>
                                <span class="stats-value" id="score-value">0</span>
                            </div>
                        </div>
                    </div>

                    <!-- Colonna destra per le informazioni e le azioni. -->
                    <div class="right-column-game">
                        <!-- Griglia che mostra le risorse del giocatore. Ogni risorsa è un 'resource-item'. -->
                        <div class="resources-section">
                            <!-- Riga 1 -->
                            <div class="resource-item">
                                <div class="resource-icon" id="shillings-icon">
                                    <!-- L'attributo 'onerror' chiama una funzione JS se l'immagine non si carica, mostrando un'icona di fallback. -->
                                    <img src="img/shillings.png" alt="Scellini" onerror="resourceImageError(this, '💷')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Scellini</div>
                                    <!-- Il valore della risorsa verrà aggiornato da JavaScript. -->
                                    <div class="resource-value" id="shillings-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="workers-icon">
                                    <img src="img/workers.png" alt="Lavoratori" onerror="resourceImageError(this, '👷')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Lavoratori</div>
                                    <div class="resource-value" id="workers-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="wool-icon">
                                    <img src="img/wool.png" alt="Lana" onerror="resourceImageError(this, '🐑')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Lana</div>
                                    <div class="resource-value" id="wool-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="whisky-icon">
                                    <img src="img/whisky.png" alt="Whisky" onerror="resourceImageError(this, '🥃')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Whisky</div>
                                    <div class="resource-value" id="whisky-value">0</div>
                                </div>
                            </div>

                            <!-- Riga 2 -->
                            <div class="resource-item">
                                <div class="resource-icon" id="peat-icon">
                                    <img src="img/peat.png" alt="Torba" onerror="resourceImageError(this, '🧱')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Torba</div>
                                    <div class="resource-value" id="peat-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="coal-icon">
                                    <img src="img/coal.png" alt="Carbone" onerror="resourceImageError(this, '🔥')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Carbone</div>
                                    <div class="resource-value" id="coal-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="iron-icon">
                                    <img src="img/iron.png" alt="Ferro" onerror="resourceImageError(this, '🔩')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Ferro</div>
                                    <div class="resource-value" id="iron-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="fish-icon">
                                    <img src="img/fish.png" alt="Pesce" onerror="resourceImageError(this, '🐟')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Pesce</div>
                                    <div class="resource-value" id="fish-value">0</div>
                                </div>
                            </div>

                            <!-- Riga 3 -->
                            <div class="resource-item">
                                <div class="resource-icon" id="lumber-icon">
                                    <img src="img/lumber.png" alt="Legname" onerror="resourceImageError(this, '🪵')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Legname</div>
                                    <div class="resource-value" id="lumber-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="oats-icon">
                                    <img src="img/oats.png" alt="Avena" onerror="resourceImageError(this, '🌾')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Avena</div>
                                    <div class="resource-value" id="oats-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="grain-icon">
                                    <img src="img/grain.png" alt="Grano" onerror="resourceImageError(this, '🌾')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Grano</div>
                                    <div class="resource-value" id="grain-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="cows-icon">
                                    <img src="img/cows.png" alt="Mucche" onerror="resourceImageError(this, '🐄')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Mucche</div>
                                    <div class="resource-value" id="cows-value">0</div>
                                </div>
                            </div>

                            <!-- Riga 4 (Nuove Risorse) -->
                            <div class="resource-item">
                                <div class="resource-icon" id="cloth-icon">
                                    <img src="img/cloth.png" alt="Tessuti" onerror="resourceImageError(this, '👕')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Tessuti</div>
                                    <div class="resource-value" id="cloth-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="tools-icon">
                                    <img src="img/tools.png" alt="Attrezzi" onerror="resourceImageError(this, '🛠️')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Attrezzi</div>
                                    <div class="resource-value" id="tools-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="stone-icon">
                                    <img src="img/stone.png" alt="Pietra" onerror="resourceImageError(this, '🪨')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Pietra</div>
                                    <div class="resource-value" id="stone-value">0</div>
                                </div>
                            </div>
                            <div class="resource-item">
                                <div class="resource-icon" id="pottery-icon">
                                    <img src="img/pottery.png" alt="Ceramiche" onerror="resourceImageError(this, '🏺')">
                                </div>
                                <div class="resource-info">
                                    <div class="resource-label">Ceramiche</div>
                                    <div class="resource-value" id="pottery-value">0</div>
                                </div>
                            </div>
                        </div>

                        <!-- Contenitore inferiore che raggruppa i pulsanti di azione e il pannello narrativo. -->
                        <div class="bottom-container">
                            <!-- Sezione per i pulsanti di azione. Verranno generati dinamicamente da JavaScript. -->
                            <div class="buttons-section">
                                <!-- I pulsanti vengono generati dinamicamente dal sistema di location -->
                            </div>

                            <!-- Sezione per il testo narrativo/guida. -->
                            <div class="narrative-section-game">
                                <div class="narrative-title" id="narrative-title">Guida</div>
                                <div class="narrative-content" id="game-narrative-content">
                                    Caricamento location...
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
                
                <!-- Footer della UI di gioco, con pulsanti e controlli. -->
                <footer class="game-ui-footer-section">
                    <!-- Sezione sinistra del footer. -->
                    <div class="footer-left">
                        <button class="back-button" onclick="backToMainMenu()">← BACK TO MAIN MENU</button>
                    </div>
                    
                    <!-- Sezione centrale del footer. -->
                    <div class="footer-center">
                        <button class="back-button" onclick="downloadSavegame()" style="background: linear-gradient(135deg, #27ae60, #229954);">💾 DOWNLOAD SAVEGAME</button>
                    </div>
                    
                    <!-- Sezione destra del footer. -->
                    <div class="footer-right">
                        <!-- Controllo del volume. -->
                        <div class="volume-control">
                            <span class="volume-icon" onclick="toggleMute()">🔊</span>
                            <input type="range" 
                                   id="volume-slider" 
                                   class="volume-slider" 
                                   min="0" 
                                   max="100" 
                                   value="0"
                                   oninput="changeVolume(this.value)">
                        </div>
                    </div>
                </footer>
            </div>
        </div>
    </div>

    <!-- ================= SISTEMA DI MODALI ================= -->
    <!-- L'overlay per i pop-up. È un singolo elemento che viene riutilizzato per tutti i modali. -->
    <!-- 'onclick' sull'overlay permette di chiudere il modale cliccando sullo sfondo. -->
    <div id="modal-overlay" class="modal-overlay" onclick="closeModalOnOverlayClick(event)">
        <!-- Il contenitore del modale. 'onclick' qui impedisce la chiusura del modale se si clicca al suo interno. -->
        <div class="modal-container" onclick="event.stopPropagation()">
            <!-- Questi elementi verranno riempiti da JavaScript con il contenuto specifico del modale. -->
            <div id="modal-image-container" class="modal-image-container"></div>
            <div id="modal-title" class="modal-title"></div>
            <div id="modal-message" class="modal-message"></div>
            <div id="modal-buttons" class="modal-buttons"></div>
        </div>
    </div>

    <!-- Elemento 'input' di tipo 'file' per importare i salvataggi. -->
    <!-- È nascosto ('display: none;') e viene attivato da un click su un pulsante tramite JavaScript. -->
    <input type="file" 
           id="savegame-file-input" 
           accept=".json" 
           style="display: none;" 
           onchange="handleSavegameFileLoad(event)">

    <!-- Inizio del blocco di codice JavaScript che contiene tutta la logica del gioco. -->
    <script>
        // ================= UTILITÀ PER L'INTERFACCIA UTENTE (UI) =================

        /**
         * Funzione di fallback per le immagini delle risorse.
         * Se un'immagine non si carica (es. percorso errato), questa funzione viene chiamata dall'attributo 'onerror' dell'<img>.
         * Sostituisce l'immagine rotta con un'icona testuale (emoji).
         * @param {HTMLElement} element - L'elemento <img> che non è riuscito a caricarsi.
         * @param {string} fallbackIcon - L'emoji o il testo da mostrare come fallback.
         */
        function resourceImageError(element, fallbackIcon) {
            // Trova il contenitore genitore dell'immagine (il div .resource-icon).
            const parent = element.parentElement;
            if (parent) {
                // Sostituisce tutto il contenuto del genitore (incluso l'<img> rotto) con l'icona di fallback.
                parent.innerHTML = fallbackIcon;
                // Aggiunge una classe per poter applicare stili specifici al fallback, se necessario.
                parent.classList.add('placeholder');
            }
        }

        // ================= GESTORE AUDIO =================
        /**
         * Classe per gestire la riproduzione audio, in particolare la musica di sottofondo.
         * Gestisce una playlist, il volume e lo stato mute.
         */
        class AudioManager {
            // Il costruttore viene chiamato quando si crea una nuova istanza della classe (new AudioManager()).
            constructor() {
                // L'oggetto Audio che riprodurrà la musica. Inizializzato a null.
                this.backgroundMusic = null;
                // L'array che conterrà i percorsi dei file musicali della playlist.
                this.musicFiles = [];
                // L'indice della traccia attualmente in riproduzione.
                this.currentTrackIndex = 0;
                // Messaggio di log per confermare l'inizializzazione.
                console.log('🔊 Audio Manager initialized');
            }

            /**
             * Avvia la riproduzione della musica di sottofondo da una lista di file.
             * @param {string[]} files - Un array di percorsi ai file musicali.
             */
            playBackgroundMusic(files) {
                // Controllo di sicurezza: non fare nulla se non vengono forniti file.
                if (!files || files.length === 0) {
                    console.error('No music files provided.');
                    return;
                }
                // Salva la playlist e resetta l'indice.
                this.musicFiles = files;
                this.currentTrackIndex = 0;

                // Se l'oggetto Audio non è ancora stato creato, lo crea.
                if (!this.backgroundMusic) {
                    this.backgroundMusic = new Audio();
                    // Il loop viene gestito manualmente per supportare playlist con più tracce.
                    this.backgroundMusic.loop = false;
                    // Aggiunge un "ascoltatore" che si attiva quando una traccia finisce.
                    // Quando finisce, chiama il metodo playNextTrack().
                    this.backgroundMusic.addEventListener('ended', () => {
                        this.playNextTrack();
                    });
                }

                // Avvia la riproduzione della prima traccia.
                this.playTrack(this.currentTrackIndex);
            }

            /**
             * Riproduce una traccia specifica dalla playlist.
             * @param {number} index - L'indice della traccia da riprodurre.
             */
            playTrack(index) {
                // Se l'indice supera la lunghezza della playlist, ricomincia da capo.
                if (index >= this.musicFiles.length) {
                    console.log('Reached end of playlist, restarting.');
                    index = 0;
                }
                this.currentTrackIndex = index;
                const track = this.musicFiles[this.currentTrackIndex];
                // Imposta il file sorgente per l'oggetto Audio.
                this.backgroundMusic.src = track;

                // Applica le impostazioni di volume e mute attuali prese dai dati del giocatore.
                this.setVolume(Player.get('settings.audio_volume'));
                this.toggleMute(Player.get('settings.is_muted'));

                // Avvia la riproduzione. .play() restituisce una Promise.
                const playPromise = this.backgroundMusic.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        // Successo: la musica sta suonando.
                        console.log(`🎵 Playing background music: ${track}`);
                    }).catch(error => {
                        // Errore: spesso accade perché il browser blocca l'autoplay prima di un'interazione dell'utente.
                        console.error(`Failed to play background music: ${error}. User interaction might be required.`);
                        // Soluzione: prova a far partire la musica al primo click dell'utente sulla pagina.
                        const playOnClick = () => {
                            this.backgroundMusic.play().then(() => {
                                console.log('🎵 Music started after user interaction.');
                            }).catch(err => {
                                console.error('Still failed to play after click:', err);
                            });
                        };
                        // Aggiunge un ascoltatore per il click che si rimuove automaticamente dopo il primo utilizzo ({ once: true }).
                        document.body.addEventListener('click', playOnClick, { once: true });
                        document.body.addEventListener('touchend', playOnClick, { once: true }); // Per dispositivi touch
                    });
                }
            }

            // Passa alla traccia successiva della playlist.
            playNextTrack() {
                this.currentTrackIndex++;
                // Se si supera la fine della playlist, torna all'inizio (loop).
                if (this.currentTrackIndex >= this.musicFiles.length) {
                    this.currentTrackIndex = 0;
                }
                this.playTrack(this.currentTrackIndex);
            }

            /**
             * Imposta il volume della musica.
             * @param {number} volume - Un valore da 0 a 100.
             */
            setVolume(volume) { // volume is 0-100
                if (this.backgroundMusic) {
                    // L'API Audio richiede un valore da 0.0 a 1.0, quindi dividiamo per 100.
                    this.backgroundMusic.volume = volume / 100;
                }
            }

            /**
             * Attiva o disattiva il mute.
             * @param {boolean} isMuted - true per silenziare, false per riattivare.
             */
            toggleMute(isMuted) {
                if (this.backgroundMusic) {
                    this.backgroundMusic.muted = isMuted;
                }
            }
        }

        // Crea un'istanza globale del gestore audio, che sarà accessibile in tutto lo script.
        const audioManager = new AudioManager();

        // ================= SISTEMA DI NAVIGAZIONE SPA (Single Page Application) =================
        
        // Variabile globale che tiene traccia dell'ID della sezione attualmente visibile.
        let currentSection = 'main-menu-section';
        
        /**
         * Gestisce la visualizzazione delle diverse "pagine" o sezioni dell'applicazione.
         * Nasconde tutte le sezioni e mostra solo quella con l'ID specificato.
         * @param {string} sectionId - L'ID dell'elemento div della sezione da mostrare.
         * @returns {boolean} - true se la sezione è stata cambiata con successo, altrimenti false.
         */
        function showSection(sectionId) {
            console.log('🎯 Cambiando sezione da', currentSection, 'a', sectionId);
            
            // Seleziona tutte le sezioni (elementi con classe .spa-section) e rimuove la classe 'active' da ognuna.
            document.querySelectorAll('.spa-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Trova la sezione di destinazione tramite il suo ID.
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                // Se trovata, aggiunge la classe 'active' per renderla visibile (come definito nel CSS).
                targetSection.classList.add('active');
                // Aggiorna la variabile globale.
                currentSection = sectionId;
                console.log('✅ Sezione cambiata con successo:', sectionId);
            } else {
                // Se non trovata, stampa un errore.
                console.error('❌ Sezione non trovata:', sectionId);
                return false;
            }
            
            // Aggiorna l'opacità dell'overlay di sfondo a seconda della sezione visualizzata.
            const overlayElement = document.querySelector('.overlay-shadow');
            if (overlayElement) {
                if (sectionId === 'cutscene-section' || sectionId === 'game-ui-section') {
                    // Rende l'overlay leggermente più scuro durante il gioco per aumentare il contrasto.
                    overlayElement.style.background = 'rgba(0, 0, 0, 0.85)';
                } else {
                    // Opacità standard per il menu principale.
                    overlayElement.style.background = 'rgba(0, 0, 0, 0.75)';
                }
            }
            
            return true;
        }

        // ================= SISTEMA DI MODALI (POP-UP) =================
        
        // Variabile globale per tenere traccia del tipo di modale attualmente aperto (es. 'confirm', 'info'). Null se nessun modale è aperto.
        let currentModal = null;
        // Oggetto globale per memorizzare le funzioni di callback (le azioni da eseguire) per i pulsanti del modale corrente.
        let currentModalCallbacks = {};
        
        /**
         * Mostra un modale di conferma con due pulsanti ("Conferma" e "Annulla").
         * @param {string} title - Il titolo del modale.
         * @param {string} message - Il messaggio di testo da visualizzare.
         * @param {function} onConfirm - La funzione da eseguire se l'utente clicca "Conferma".
         * @param {function|null} onCancel - La funzione opzionale da eseguire se l'utente clicca "Annulla".
         * @param {string|null} imageUrl - L'URL opzionale di un'immagine da mostrare nel modale.
         */
        function showConfirmModal(title, message, onConfirm, onCancel = null, imageUrl = null) {
            // Ottiene i riferimenti agli elementi HTML del modale.
            const overlay = document.getElementById('modal-overlay');
            const imageContainer = document.getElementById('modal-image-container');
            const titleElement = document.getElementById('modal-title');
            const messageElement = document.getElementById('modal-message');
            const buttonsElement = document.getElementById('modal-buttons');
            
            // Log per il debug.
            console.log('🎯 Mostrando modale di conferma:', title);
            
            // Gestisce l'immagine: usa quella fornita o un'immagine segnaposto.
            const finalImageUrl = imageUrl || 'https://via.placeholder.com/150/808080/FFFFFF?Text=IMG';
            imageContainer.innerHTML = `<img src="${finalImageUrl}" alt="Modal Image">`;
            imageContainer.style.display = 'block'; // Rende visibile il contenitore dell'immagine.

            // Imposta il contenuto del modale.
            titleElement.textContent = title;
            titleElement.className = 'modal-title confirm-title'; // Applica la classe per l'icona di avvertimento.
            messageElement.textContent = message;
            
            // Memorizza le funzioni di callback, assicurandosi che siano effettivamente funzioni.
            currentModalCallbacks = {
                confirm: typeof onConfirm === 'function' ? onConfirm : null,
                cancel: typeof onCancel === 'function' ? onCancel : null
            };
            
            // Genera dinamicamente i pulsanti nel contenitore.
            buttonsElement.innerHTML = `
                <button class="modal-button cancel" onclick="executeModalAction('cancel')">ANNULLA</button>
                <button class="modal-button confirm" onclick="executeModalAction('confirm')">CONFERMA</button>
            `;
            
            // Mostra il modale aggiungendo la classe 'active' all'overlay.
            overlay.classList.add('active');
            currentModal = 'confirm'; // Imposta lo stato del modale corrente.
            
            // Imposta il focus sul pulsante di conferma dopo un breve ritardo per permettere l'animazione.
            setTimeout(() => {
                const confirmBtn = buttonsElement.querySelector('.confirm');
                if (confirmBtn) confirmBtn.focus();
            }, 300);
        }
        
        /**
         * Mostra un modale informativo con un solo pulsante ("Continua").
         * @param {string} title - Il titolo del modale.
         * @param {string} message - Il messaggio di testo.
         * @param {function|null} onContinue - La funzione opzionale da eseguire dopo la chiusura.
         * @param {string} type - Il tipo di modale ('info', 'success', etc.) per cambiare l'icona e il colore del pulsante.
         * @param {string|null} imageUrl - L'URL opzionale di un'immagine.
         */
        function showInfoModal(title, message, onContinue = null, type = 'info', imageUrl = null) {
            const overlay = document.getElementById('modal-overlay');
            const imageContainer = document.getElementById('modal-image-container');
            const titleElement = document.getElementById('modal-title');
            const messageElement = document.getElementById('modal-message');
            const buttonsElement = document.getElementById('modal-buttons');
            
            console.log('ℹ️ Mostrando modale informativo:', title);
            
            const finalImageUrl = imageUrl || 'https://via.placeholder.com/150/808080/FFFFFF?Text=IMG';
            imageContainer.innerHTML = `<img src="${finalImageUrl}" alt="Modal Image">`;
            imageContainer.style.display = 'block';

            titleElement.textContent = title;
            titleElement.className = `modal-title ${type}-title`; // Applica la classe per l'icona corretta.
            messageElement.textContent = message;
            
            // Memorizza la callback.
            currentModalCallbacks = {
                continue: typeof onContinue === 'function' ? onContinue : null
            };
            
            // Determina il colore del pulsante in base al tipo di modale.
            const buttonClass = type === 'success' ? 'confirm' : 'info';
            buttonsElement.innerHTML = `
                <button class="modal-button ${buttonClass}" onclick="executeModalAction('continue')">CONTINUA</button>
            `;
            
            overlay.classList.add('active');
            currentModal = 'info';
            
            setTimeout(() => {
                const continueBtn = buttonsElement.querySelector(`.${buttonClass}`);
                if (continueBtn) continueBtn.focus();
            }, 300);
        }
        
        /**
         * Mostra un modale con un campo di input per l'utente (es. inserire il nome).
         * @param {string} title - Il titolo del modale.
         * @param {string} message - Il messaggio di testo sopra l'input.
         * @param {string} placeholder - Il testo segnaposto per il campo di input.
         * @param {function} onConfirm - La funzione da eseguire alla conferma, riceve il valore dell'input come parametro.
         * @param {function|null} onCancel - La funzione opzionale per l'annullamento.
         * @param {string|null} imageUrl - L'URL opzionale di un'immagine.
         */
        function showNameInputModal(title, message, placeholder, onConfirm, onCancel = null, imageUrl = null) {
            const overlay = document.getElementById('modal-overlay');
            const imageContainer = document.getElementById('modal-image-container');
            const titleElement = document.getElementById('modal-title');
            const messageElement = document.getElementById('modal-message');
            const buttonsElement = document.getElementById('modal-buttons');

            console.log('📝 Mostrando modale con input:', title);

            const finalImageUrl = imageUrl || 'https://via.placeholder.com/150/808080/FFFFFF?Text=IMG';
            imageContainer.innerHTML = `<img src="${finalImageUrl}" alt="Modal Image">`;
            imageContainer.style.display = 'block';

            titleElement.textContent = title;
            titleElement.className = 'modal-title info-title';
            // Inserisce l'HTML per il messaggio e il campo di input.
            messageElement.innerHTML = `
                ${message}
                <div class="modal-input-container">
                    <input type="text" id="modal-input-field" class="modal-input" placeholder="${placeholder}">
                </div>
            `;

            // Memorizza le callback. La callback di conferma viene avvolta in una funzione per poter leggere il valore dell'input.
            currentModalCallbacks = {
                confirm: () => {
                    const inputField = document.getElementById('modal-input-field');
                    if (onConfirm && typeof onConfirm === 'function') {
                        // Passa il valore dell'input alla funzione di callback originale.
                        onConfirm(inputField.value);
                    }
                },
                cancel: typeof onCancel === 'function' ? onCancel : null
            };

            buttonsElement.innerHTML = `
                <button class="modal-button cancel" onclick="executeModalAction('cancel')">ANNULLA</button>
                <button class="modal-button confirm" onclick="executeModalAction('confirm')">CONFERMA</button>
            `;

            overlay.classList.add('active');
            currentModal = 'input'; // Nuovo tipo di modale per una gestione specifica (es. tasto Enter).

            // Imposta il focus sul campo di input.
            setTimeout(() => {
                const inputField = document.getElementById('modal-input-field');
                if (inputField) {
                    inputField.focus();
                    // Aggiunge un listener per il tasto "Enter" per confermare facilmente.
                    inputField.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault(); // Previene il comportamento di default (es. invio di un form).
                            executeModalAction('confirm');
                        }
                    });
                }
            }, 300);
        }

        /**
         * Funzione centrale che esegue la callback associata a un'azione del modale (es. 'confirm', 'cancel').
         * @param {string} action - Il nome dell'azione da eseguire (es. 'confirm', 'cancel', 'continue').
         */
        function executeModalAction(action) {
            // Esegue la callback corrispondente all'azione, se esiste ed è una funzione.
            const callback = currentModalCallbacks[action];
            if (callback && typeof callback === 'function') {
                try {
                    callback();
                } catch (error) {
                    console.error('❌ Errore nell\'esecuzione della callback:', error);
                }
            }
            
            // Chiude il modale DOPO aver eseguito la callback.
            closeModal();
        }
        
        /**
         * Chiude qualsiasi modale attualmente aperto.
         */
        function closeModal() {
            const overlay = document.getElementById('modal-overlay');
            // Rimuove la classe 'active' per nascondere l'overlay (e il suo contenuto) con un'animazione.
            overlay.classList.remove('active');
            // Resetta le variabili di stato globali.
            currentModal = null;
            currentModalCallbacks = {};
        }
        
        /**
         * Permette di chiudere il modale cliccando sull'overlay di sfondo.
         * @param {Event} event - L'evento click.
         */
        function closeModalOnOverlayClick(event) {
            // Controlla se l'elemento cliccato è l'overlay stesso e non un suo figlio (come il .modal-container).
            if (event.target.id === 'modal-overlay') {
                closeModal();
            }
        }
        
        /**
         * Aggiunge un listener globale per gestire i tasti della tastiera.
         */
        document.addEventListener('keydown', function(event) {
            // Se un modale è aperto, gestisce i tasti ESC e Enter.
            if (currentModal) {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeModal(); // Chiude il modale con ESC.
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    // Esegue l'azione di conferma/continuazione con Enter.
                    if (currentModal === 'confirm' || currentModal === 'input') {
                        executeModalAction('confirm');
                    } else if (currentModal === 'info') {
                        executeModalAction('continue');
                    }
                }
                return; // Impedisce l'esecuzione di altri listener di tastiera quando un modale è aperto.
            }
            
            // Altrimenti, se nessun modale è aperto, gestisce gli shortcut del gioco.
            if (currentSection === 'cutscene-section') {
                if (event.key === 'Enter' || event.key === ' ') { // Spazio o Invio per continuare.
                    event.preventDefault();
                    continueCutscene();
                }
            } else if (currentSection === 'game-ui-section') {
                // Esempi di shortcut (attualmente non funzionanti perché le funzioni sono state rimosse/modificate).
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    // actionButton2(); // Continua
                }
                if (event.key === 'Escape') {
                    event.preventDefault();
                    // actionButton3(); // Salta
                }
                if (event.key === 'i' || event.key === 'I') {
                    event.preventDefault();
                    // actionButton1(); // Inventario
                }
            }
        });

        // ================= FUNZIONI DEL MENU PRINCIPALE =================
        
        /**
         * Avvia una nuova partita.
         * Chiede al giocatore di inserire un nome, resetta i dati di gioco e avvia la prima cutscene.
         */
        function startNewGame() {
            console.log('🎮 Avviando nuova partita...');

            // Mostra un modale per l'inserimento del nome.
            showNameInputModal(
                "INIZIA UNA NUOVA AVVENTURA",
                "Inserisci il nome del tuo eroe per iniziare il viaggio.",
                "Nome dell'Eroe...",
                // Funzione di callback per la conferma (onConfirm).
                (playerName) => {
                    // Controlla se il nome è valido.
                    if (!playerName || playerName.trim() === "") {
                        showInfoModal("NOME NON VALIDO", "Per favore, inserisci un nome per il tuo eroe.");
                        return; // Interrompe l'esecuzione se il nome non è valido.
                    }

                    console.log(`✅ Nome scelto: ${playerName}. Resetto i dati di gioco.`);
                    // Salva il nome del giocatore nei dati persistenti.
                    Player.set('profile.playerName', playerName.trim());

                    // Reset profondo dei dati di gioco ai valori di default.
                    // JSON.parse(JSON.stringify(...)) è un trucco per creare una copia profonda (deep copy) dell'oggetto,
                    // evitando che le modifiche a Player.data influenzino Player.defaultData.
                    Player.data.resources = JSON.parse(JSON.stringify(Player.defaultData.resources));
                    Player.data.progress = JSON.parse(JSON.stringify(Player.defaultData.progress));
                    Player.data.inventory = JSON.parse(JSON.stringify(Player.defaultData.inventory));
                    Player.data.stats = JSON.parse(JSON.stringify(Player.defaultData.stats));
                    Player.data.profile.level = 1;
                    Player.data.profile.experience = 0;
                    Player.data.gameData = JSON.parse(JSON.stringify(Player.defaultData.gameData));

                    // Forza un salvataggio immediato dei dati resettati.
                    Player.saveData(true);
                    // Aggiorna la visualizzazione delle risorse nell'interfaccia.
                    updateResourcesDisplay();

                    // Passa alla sezione della cutscene.
                    showSection('cutscene-section');
                    // Carica i dati per la prima cutscene.
                    loadCutsceneData("cutscene_01");
                },
                // Funzione di callback per l'annullamento (onCancel).
                () => {
                    console.log('❌ Creazione nuova partita annullata.');
                }
            );
        }

        /**
         * Carica una partita esistente.
         * Passa alla schermata di gioco e inizializza l'interfaccia con i dati salvati.
         */
        function loadGame() {
            console.log('📁 Caricando partita...');
            
            // Mostra la sezione dell'interfaccia di gioco.
            const sectionChanged = showSection('game-ui-section');
            
            if (sectionChanged) {
                // Usa setTimeout per assicurarsi che il DOM sia stato aggiornato prima di eseguire la logica di gioco.
                setTimeout(() => {
                    console.log('🎮 Inizializzando Game UI dopo cambio sezione...');
                    initializeGameUI();
                }, 100); // Un piccolo ritardo è sufficiente.
            } else {
                console.error('❌ Errore nel cambio sezione al Game UI');
            }
        }

        /**
         * Mostra la finestra di dialogo per importare un file di salvataggio.
         * Lo fa simulando un click sull'elemento <input type="file"> nascosto.
         */
        function showImportSavegame() {
            console.log('📥 Aprendo import savegame...');
            document.getElementById('savegame-file-input').click();
        }

        /**
         * Mostra un modale informativo per le opzioni (funzione non ancora implementata).
         */
        function showHallOfFame() {
            console.log('🏆 Mostrando Hall of Fame...');
            showSection('hall-of-fame-section');
        }

        function showOptions() {
            console.log('⚙️ Aprendo opzioni...');
            showInfoModal(
                "OPZIONI",
                "Menu opzioni non ancora implementato.\n\nQuesta funzione sarà disponibile in una versione futura del gioco.",
                null,
                'info'
            );
        }

        /**
         * Mostra un modale informativo con i crediti del gioco.
         */
        function showCredits() {
            console.log('👨‍💻 Mostrando crediti...');
            showInfoModal(
                "CREDITI",
                "Gioco creato con passione utilizzando HTML5, CSS3 e JavaScript.\n\nGrazie per aver giocato!",
                null,
                'info'
            );
        }

        /**
         * Mostra la sezione del tutorial (attualmente ricarica la cutscene iniziale).
         */
        function showTutorial() {
            console.log('📚 Avviando tutorial...');
            showSection('cutscene-section');
            // In un gioco completo, qui si caricherebbe una cutscene o una location specifica per il tutorial.
        }

        /**
         * Chiede conferma per uscire dal gioco e, in caso affermativo, reindirizza l'utente a un'altra pagina.
         */
        function exitGame() {
            console.log('🚪 Richiesta uscita dal gioco...');
            showConfirmModal(
                "USCITA DAL GIOCO",
                "Sei sicuro di voler uscire dal gioco?\n\nVerrai reindirizzato a Google.",
                // Callback di conferma.
                function() {
                    console.log('✅ Confermata uscita dal gioco - reindirizzando immediatamente');
                    // Reindirizza la finestra del browser a google.com.
                    window.location.href = 'https://www.google.com';
                },
                // Callback di annullamento.
                function() {
                    console.log('❌ Uscita annullata');
                },
                'exit_image.png'
            );
        }

        // ================= FUNZIONI PER LE CUTSCENE =================
        
        // Dati di esempio per le cutscene. In un gioco reale, questi dati verrebbero caricati da un file JSON esterno.
        const cutsceneData = {
            "cutscene_01": {
                "title": "L'Inizio dell'Avventura",
                "narrative": "Era una notte buia e tempestosa quando il nostro eroe iniziò il suo viaggio. Le stelle erano nascoste dalle nuvole cariche di pioggia, e solo il bagliore intermittente dei fulmini illuminava il sentiero tortuoso che si estendeva davanti a lui.\n\nCon il cuore pieno di determinazione e la mente concentrata sull'obiettivo, prese il primo passo verso un destino che avrebbe cambiato per sempre il corso della sua vita. Non sapeva ancora quali sfide lo attendevano, ma era pronto ad affrontare qualsiasi ostacolo.\n\nIl vento ululava tra gli alberi spogli, creando una sinfonia inquietante che accompagnava ogni suo passo. Ad ogni lampo, ombre danzanti sembravano prendere vita, ma la sua determinazione non vacillava mai.",
                "image": "cutscene_01.png"
            },
            "cutscene_02": {
                "title": "L'Incontro Fatale",
                "narrative": "Mentre si dirigeva verso il villaggio, un rumore strano attirò la sua attenzione. Tra i cespugli, una figura misteriosa lo osservava con occhi brillanti nel buio. Era questo l'incontro che avrebbe segnato l'inizio di una grande alleanza o di una terribile minaccia?\n\nLa figura si mosse lentamente, emergendo dalle ombre. Indossava un mantello scuro che ondeggiava nel vento, e i suoi occhi sembravano brillare di una luce propria. Il nostro eroe strinse la spada, pronto a tutto.",
                "image": "path/to/cutscene_02_image.jpg"
            }
        };

        // Variabile per tenere traccia dell'ID della cutscene corrente.
        let currentCutsceneId = "cutscene_01";

        /**
         * Carica i dati di una specifica cutscene nell'interfaccia utente.
         * @param {string} cutsceneId - L'ID della cutscene da caricare (deve essere una chiave in `cutsceneData`).
         */
        function loadCutsceneData(cutsceneId) {
            // Recupera i dati della cutscene dall'oggetto 'cutsceneData'.
            const data = cutsceneData[cutsceneId];
            if (data) {
                // Aggiorna il titolo della cutscene.
                const titleElement = document.getElementById('cutscene-title');
                titleElement.textContent = data.title.toUpperCase();
                titleElement.setAttribute('data-text', data.title.toUpperCase());
                
                // Aggiorna il testo narrativo, sostituendo i ritorni a capo (\n) con tag <br> per la formattazione HTML.
                document.getElementById('cutscene-narrative-content').innerHTML = data.narrative.replace(/\n/g, '<br><br>');
                
                // Carica l'immagine della cutscene.
                const imageContainer = document.querySelector('#cutscene-section .image-container');
                // Controlla se un'immagine valida è specificata.
                if (data.image && data.image !== "path/to/cutscene_01_image.jpg") {
                    // Se sì, inserisce l'elemento <img> nel contenitore.
                    // 'onload' viene usato per creare una piccola animazione di dissolvenza quando l'immagine è pronta.
                    imageContainer.innerHTML = `<img src="${data.image}" alt="Cutscene Image" onload="this.style.opacity=1" style="opacity:0;transition:opacity 0.3s;">`;
                } else {
                    // Altrimenti, mostra il testo segnaposto.
                    imageContainer.innerHTML = '<div class="image-placeholder">Immagine della cutscene qui</div>';
                }
            }
        }

        /**
         * Funzione chiamata quando l'utente clicca sul pulsante "CONTINUA" durante una cutscene.
         * Determina se passare alla cutscene successiva o iniziare il gioco.
         */
        function continueCutscene() {
            // Logica di esempio per una sequenza di cutscene.
            if (currentCutsceneId === "cutscene_01") {
                // Se siamo alla prima cutscene, passiamo alla seconda.
                currentCutsceneId = "cutscene_02";
                loadCutsceneData(currentCutsceneId);
            } else {
                // Se siamo all'ultima cutscene, passiamo all'interfaccia di gioco.
                showSection('game-ui-section');
                initializeGameUI();
            }
        }

        // ================= SISTEMA DI GESTIONE DATI GIOCATORE =================
        
        /**
         * Classe completa per la gestione dei dati del giocatore.
         * Gestisce il caricamento, salvataggio (anche automatico), la modifica e la migrazione dei dati.
         * Utilizza il localStorage del browser per la persistenza dei dati.
         */
        class PlayerDataManager {
            // Il costruttore imposta le proprietà iniziali e avvia il sistema.
            constructor() {
                // La chiave usata per salvare i dati nel localStorage. Cambiare questa chiave isolerà i dati di versioni diverse.
                this.saveKey = 'game_player_data';
                // La versione attuale della struttura dei dati. Utile per future migrazioni.
                this.saveVersion = '1.0.0';
                // Intervallo per il salvataggio automatico (in millisecondi).
                this.autoSaveInterval = 5000; // 5 secondi
                // Riferimento al timer dell'auto-save, per poterlo fermare.
                this.autoSaveTimer = null;
                
                // Un oggetto "template" che definisce la struttura completa e i valori di default per una nuova partita.
                // Questo è cruciale per garantire che tutti i dati abbiano una struttura consistente.
                this.defaultData = {
                    // === META INFORMAZIONI ===
                    meta: {
                        version: this.saveVersion,
                        lastSaved: new Date().toISOString(),
                    },
                    
                    // === PROFILO DEL GIOCATORE ===
                    profile: {
                        playerName: 'Eroe Senza Nome',
                        level: 1,
                        experience: 0,
                        experienceToNext: 100,
                        class: 'avventuriero',
                        avatar: 'default.png'
                    },
                    
                    // === STATISTICHE DI GIOCO ===
                    stats: {
                        forza: 10,
                        difesa: 8,
                        agilita: 12,
                    },
                    
                    // === RISORSE DEL GIOCATORE ===
                    resources: {
                        shillings: 0,
                        workers: 2,
                        wool: 0,
                        whisky: 0,
                        peat: 0,
                        coal: 0,
                        iron: 0,
                        fish: 0,
                        lumber: 0,
                        oats: 0,
                        grain: 50,
                        cows: 2,
                        cloth: 0,
                        tools: 0,
                        stone: 0,
                        pottery: 0
                    },
                    
                    // === INVENTARIO ===
                    inventory: {
                        maxSlots: 20,
                        items: [],
                        equipment: {
                            weapon: null,
                            armor: null,
                        }
                    },
                    
                    // === PROGRESSIONE NEL GIOCO ===
                    progress: {
                        currentChapter: 1,
                        completedQuests: [],
                        activeQuests: [],
                        unlockedAreas: ['location_1'],
                    },
                    
                    // === IMPOSTAZIONI UTENTE ===
                    settings: {
                        audio_volume: 0,
                        is_muted: false,
                        autoSave: true,
                    },
                    
                    // === DATI DI STATO DEL GIOCO ===
                    gameData: {
                        currentBoardPosition: 0,
                        currentLocation: 'location_1',
                        currentYear: 1, // Anno di gioco attuale
                        gameFlags: {}
                    }
                };
                
                // Al momento della creazione, carica i dati esistenti o, se non presenti, usa i dati di default.
                this.data = this.loadData();
                
                // Avvia il sistema di salvataggio automatico.
                this.startAutoSave();
            }
            
            /**
             * Carica i dati del giocatore dal localStorage.
             * Se non trova dati, o se sono corrotti/obsoleti, ritorna i dati di default.
             * @returns {object} I dati del giocatore.
             */
            loadData() {
                try {
                    const saved = localStorage.getItem(this.saveKey);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        
                        // Controlla se la versione dei dati salvati corrisponde a quella attuale.
                        if (parsed.meta && parsed.meta.version === this.saveVersion) {
                            console.log('✅ Dati giocatore caricati dalla versione', parsed.meta.version);
                            // Unisce i dati salvati con quelli di default per aggiungere eventuali nuove proprietà mancanti.
                            return this.mergeWithDefaults(parsed, this.defaultData);
                        } else {
                            console.log('⚠️ Versione save file non compatibile, applico migrazione...');
                            // Se la versione è diversa, tenta una migrazione.
                            return this.migrateSaveData(parsed);
                        }
                    }
                } catch (error) {
                    console.error('❌ Errore caricamento dati:', error);
                }
                
                // Se non ci sono dati salvati o si è verificato un errore, inizia una nuova partita.
                console.log('🆕 Inizializzazione nuova partita con dati di default');
                return JSON.parse(JSON.stringify(this.defaultData)); // Ritorna una copia profonda dei dati di default.
            }
            
            /**
             * Salva l'oggetto 'this.data' nel localStorage.
             * @param {boolean} immediate - Se true, logga un messaggio specifico per il salvataggio forzato.
             * @returns {boolean} - true se il salvataggio è riuscito, altrimenti false.
             */
            saveData(immediate = false) {
                try {
                    // Aggiorna i metadati prima di salvare.
                    this.data.meta.lastSaved = new Date().toISOString();
                    this.data.meta.version = this.saveVersion;
                    
                    // Converte l'oggetto dati in una stringa JSON e lo salva.
                    localStorage.setItem(this.saveKey, JSON.stringify(this.data));
                    
                    if (immediate) {
                        console.log('💾 Dati salvati immediatamente');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('❌ Errore salvataggio:', error);
                    return false;
                }
            }
            
            /**
             * Avvia il timer per il salvataggio automatico, se abilitato nelle impostazioni.
             */
            startAutoSave() {
                if (this.data.settings.autoSave) {
                    // setInterval esegue la funzione fornita ogni N millisecondi.
                    this.autoSaveTimer = setInterval(() => {
                        this.saveData();
                        console.log('🔄 Auto-save completato');
                    }, this.autoSaveInterval);
                }
            }
            
            /**
             * Ferma il timer per il salvataggio automatico.
             */
            stopAutoSave() {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                    this.autoSaveTimer = null;
                }
            }
            
            /**
             * Metodo "getter" sicuro per recuperare una proprietà (anche annidata) dai dati del giocatore.
             * @param {string} path - Il percorso della proprietà (es. 'profile.playerName').
             * @returns {*} - Il valore della proprietà, o undefined se non trovata.
             */
            get(path) {
                return this.getNestedProperty(this.data, path);
            }
            
            /**
             * Metodo "setter" sicuro per impostare una proprietà (anche annidata).
             * Il salvataggio automatico si occuperà della persistenza.
             * @param {string} path - Il percorso della proprietà da impostare.
             * @param {*} value - Il nuovo valore.
             */
            set(path, value) {
                this.setNestedProperty(this.data, path, value);
            }
            
            // --- METODI DI UTILITÀ SPECIFICI DEL GIOCO ---

            /**
             * Aggiunge una quantità a una risorsa.
             * @param {string} type - Il nome della risorsa (es. 'shillings').
             * @param {number} amount - La quantità da aggiungere.
             * @returns {boolean} - true se l'operazione è riuscita.
             */
            addResource(type, amount) {
                if (this.data.resources[type] !== undefined) {
                    this.data.resources[type] += amount;
                    return true;
                }
                return false;
            }
            
            /**
             * Rimuove una quantità da una risorsa, controllando di averne abbastanza.
             * @param {string} type - Il nome della risorsa.
             * @param {number} amount - La quantità da rimuovere.
             * @returns {boolean} - true se la risorsa è stata rimossa, false se non ce n'erano abbastanza.
             */
            removeResource(type, amount) {
                if (this.data.resources[type] !== undefined && this.data.resources[type] >= amount) {
                    this.data.resources[type] -= amount;
                    return true;
                }
                return false;
            }
            
            /**
             * Aggiunge esperienza e controlla se il giocatore sale di livello.
             * @param {number} amount - La quantità di esperienza da aggiungere.
             */
            addExperience(amount) {
                this.data.profile.experience += amount;
                this.checkLevelUp();
            }
            
            /**
             * Controlla se l'esperienza attuale è sufficiente per salire di livello.
             * Può gestire più level-up contemporaneamente con un ciclo while.
             */
            checkLevelUp() {
                while (this.data.profile.experience >= this.data.profile.experienceToNext) {
                    this.data.profile.experience -= this.data.profile.experienceToNext;
                    this.data.profile.level++;
                    // Aumenta l'esperienza necessaria per il prossimo livello (es. del 50%).
                    this.data.profile.experienceToNext = Math.floor(this.data.profile.experienceToNext * 1.5);
                    console.log(`🎉 LEVEL UP! Nuovo livello: ${this.data.profile.level}`);
                }
            }
            
            // --- UTILITÀ INTERNE DELLA CLASSE ---
            
            /**
             * Funzione helper per recuperare una proprietà annidata da un oggetto usando una stringa.
             * @param {object} obj - L'oggetto da cui leggere.
             * @param {string} path - Il percorso, es. "a.b.c".
             */
            getNestedProperty(obj, path) {
                // "a.b.c".split('.') -> ["a", "b", "c"]
                // reduce esegue una funzione per ogni elemento dell'array.
                // Inizia con 'obj' e ad ogni passo accede alla proprietà successiva.
                // o && o[p] previene errori se un livello intermedio è null o undefined.
                return path.split('.').reduce((o, p) => o && o[p], obj);
            }
            
            /**
             * Funzione helper per impostare una proprietà annidata in un oggetto usando una stringa.
             * @param {object} obj - L'oggetto da modificare.
             * @param {string} path - Il percorso, es. "a.b.c".
             * @param {*} value - Il valore da impostare.
             */
            setNestedProperty(obj, path, value) {
                const keys = path.split('.');
                const lastKey = keys.pop(); // Estrae l'ultima chiave.
                // Scorre le chiavi per trovare l'oggetto target, creandolo se non esiste.
                const target = keys.reduce((o, k) => o[k] = o[k] || {}, obj);
                target[lastKey] = value; // Imposta il valore sull'ultima chiave.
            }
            
            /**
             * Unisce ricorsivamente i dati salvati con i dati di default.
             * Questo assicura che se una nuova versione del gioco aggiunge proprietà, queste vengano aggiunte ai salvataggi esistenti.
             * @param {object} saved - I dati caricati dal salvataggio.
             * @param {object} defaults - Il template dei dati di default.
             */
            mergeWithDefaults(saved, defaults) {
                function merge(target, source) {
                    for (const key in source) {
                        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                            target[key] = target[key] || {};
                            merge(target[key], source[key]);
                        } else if (target[key] === undefined) {
                            target[key] = source[key];
                        }
                    }
                    return target;
                }
                return merge(saved, defaults);
            }

            /**
             * Gestisce la migrazione da una vecchia versione di dati a una nuova.
             * (Logica semplificata per questo esempio).
             * @param {object} oldData - I dati della vecchia versione.
             * @returns {object} - I dati migrati alla nuova versione.
             */
            migrateSaveData(oldData) {
                console.log('🔄 Migrazione dati in corso...');
                const migrated = JSON.parse(JSON.stringify(this.defaultData));
                
                // Esempio di logica di migrazione: copia le proprietà compatibili.
                if (oldData.resources) {
                    Object.assign(migrated.resources, oldData.resources);
                }
                if (oldData.profile) {
                    Object.assign(migrated.profile, oldData.profile);
                }
                // ... si potrebbero aggiungere altre regole di migrazione qui ...
                
                console.log('✅ Migrazione completata');
                return migrated;
            }
            
            /**
             * Esporta i dati di gioco correnti come stringa JSON formattata.
             * @returns {string}
             */
            exportSave() {
                return JSON.stringify(this.data, null, 2); // null, 2 formatta il JSON per essere leggibile.
            }
            
            /**
             * Importa un salvataggio da una stringa JSON.
             * @param {string} saveString - La stringa JSON del salvataggio.
             * @returns {boolean} - true se l'importazione è riuscita.
             */
            importSave(saveString) {
                try {
                    const imported = JSON.parse(saveString);
                    this.data = this.mergeWithDefaults(imported, this.defaultData);
                    this.saveData(true); // Salva immediatamente i dati importati.
                    return true;
                } catch (error) {
                    console.error('❌ Errore importazione save:', error);
                    return false;
                }
            }
            
            /**
             * Resetta completamente i dati di gioco, chiedendo conferma all'utente.
             */
            resetGame() {
                showConfirmModal(
                    "RESET COMPLETO",
                    "Sei sicuro di voler resettare tutti i dati di gioco?\n\nQuesta azione è irreversibile!",
                    () => {
                        localStorage.removeItem(this.saveKey); // Rimuove il salvataggio.
                        this.data = JSON.parse(JSON.stringify(this.defaultData)); // Carica i dati di default.
                        this.saveData(true);
                        console.log('🗑️ Dati di gioco resettati');
                        
                        // Aggiorna l'UI se la funzione esiste.
                        if (typeof updateResourcesDisplay === 'function') {
                            updateResourcesDisplay();
                        }
                        
                        showInfoModal(
                            "RESET COMPLETATO",
                            "Dati di gioco resettati con successo!",
                            null,
                            'success'
                        );
                    }
                );
            }
        }
        
        // Crea un'istanza globale del gestore dati. Sarà accessibile come 'Player' in tutto lo script.
        const Player = new PlayerDataManager();
        
        // Crea un alias per accedere direttamente all'oggetto dei dati, per retrocompatibilità o comodità.
        const playerData = Player.data;

        // ================= SISTEMA DI GIOCO DINAMICO =================
        
        // --- TABELLONE E LOCATION ---

        // Definisce l'ordine sequenziale delle location sul tabellone di gioco.
        // Il giocatore si muoverà lungo questo array.
        const gameBoard = [
            'location_1', 'location_2', 'location_3', 'location_4', 'location_5',
            'location_6', 'location_7', 'location_8', 'location_9', 'location_10'
        ];

        // Database delle location. Ogni oggetto rappresenta una casella del tabellone
        // con le sue proprietà e azioni possibili. Questo approccio è data-driven:
        // per aggiungere o modificare una location, basta modificare questo oggetto.
        const gameLocations = {
            "location_1": {
                id: "location_1",
                title: "Fattoria",
                image: "locations/farm.jpg",
                guideText: "La tua fattoria. Qui puoi coltivare grano e avena, e prenderti cura delle mucche.",
                // Array di pulsanti/azioni disponibili in questa location.
                buttons: [
                    // Ogni oggetto pulsante definisce il testo, lo stile e una lista di azioni.
                    {
                        id: "farm_grain",
                        text: "Coltiva Grano",
                        class: "action-button",
                        hoverText: "Usa un lavoratore per produrre 20 grano.",
                        // La lista di azioni da eseguire quando il pulsante viene premuto.
                        actions: [
                            { type: "removeResource", resource: "workers", amount: 1 },
                            { type: "addResource", resource: "grain", amount: 20 },
                            { type: "showMessage", title: "Grano Raccolto", message: "Hai prodotto 20 unità di grano." }
                        ]
                    },
                    { id: "farm_oats", text: "Coltiva Avena", class: "action-button", hoverText: "Usa un lavoratore per produrre 20 avena.", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "oats", amount: 20 }, { type: "showMessage", title: "Avena Raccolta", message: "Hai prodotto 20 unità di avena." }] },
                    { id: "farm_cows", text: "Vendi Latte", class: "action-button", hoverText: "Guadagna 15 scellini dal latte delle tue mucche.", actions: [{ type: "addResource", resource: "shillings", amount: 15 }, { type: "showMessage", title: "Latte Venduto", message: "Hai guadagnato 15 scellini." }] }
                ]
            },
            "location_2": {
                id: "location_2",
                title: "Mercato",
                image: "locations/merchant_guild.jpg",
                guideText: "Il mercato cittadino. Vendi i tuoi beni e assumi nuovi lavoratori.",
                buttons: [
                    { id: "market_sell_produce", text: "Vendi Raccolti", class: "action-button success", hoverText: "Vendi 20 grano e 20 avena per 30 scellini.", actions: [{ type: "removeResource", resource: "grain", amount: 20 }, { type: "removeResource", resource: "oats", amount: 20 }, { type: "addResource", resource: "shillings", amount: 30 }, { type: "showMessage", title: "Raccolti Venduti", message: "Hai venduto grano e avena per 30 scellini." }] },
                    { id: "market_buy_cow", text: "Compra Mucca", class: "action-button", hoverText: "Compra una mucca per 50 scellini.", actions: [{ type: "removeResource", resource: "shillings", amount: 50 }, { type: "addResource", resource: "cows", amount: 1 }, { type: "showMessage", title: "Mucche Comprate", message: "Hai una nuova mucca nella stalla." }] },
                    { id: "market_hire_worker", text: "Assumi Lavoratore", class: "action-button", hoverText: "Assumi un nuovo lavoratore per 20 scellini.", actions: [{ type: "removeResource", resource: "shillings", amount: 20 }, { type: "addResource", resource: "workers", amount: 1 }, { type: "showMessage", title: "Lavoratore Assunto", message: "Un nuovo lavoratore si unisce alla tua causa." }] }
                ]
            },
            "location_3": {
                id: "location_3",
                title: "Segheria",
                image: "locations/lumber_market.jpg",
                guideText: "La segheria ai margini della foresta. L'aria profuma di legno tagliato.",
                buttons: [
                    { id: "lumber_cut", text: "Taglia Legname", class: "action-button", hoverText: "Usa un lavoratore per produrre 30 legname.", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "lumber", amount: 30 }, { type: "showMessage", title: "Legname Raccolto", message: "Hai prodotto 30 unità di legname." }] },
                    { id: "lumber_sell", text: "Vendi Legname", class: "action-button success", hoverText: "Vendi 30 legname per 25 scellini.", actions: [{ type: "removeResource", resource: "lumber", amount: 30 }, { type: "addResource", resource: "shillings", amount: 25 }, { type: "showMessage", title: "Legname Venduto", message: "Hai venduto 30 legname per 25 scellini." }] },
                    { id: "lumber_event", text: "Attrezzi Rotti", class: "action-button danger", hoverText: "Devi riparare gli attrezzi.", actions: [{ type: "removeResource", resource: "shillings", amount: 5 }, { type: "showMessage", title: "Riparazione", message: "Hai speso 5 scellini per riparare un'ascia." }] }
                ]
            },
            "location_4": {
                id: "location_4",
                title: "Miniera",
                image: "locations/coal_mine.jpg",
                guideText: "Una miniera scura e profonda. Ricca di carbone e ferro.",
                buttons: [
                    { id: "mine_coal", text: "Estrai Carbone", class: "action-button", hoverText: "Usa un lavoratore per estrarre 20 carbone.", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "coal", amount: 20 }, { type: "showMessage", title: "Carbone Estratto", message: "Hai estratto 20 carbone." }] },
                    { id: "mine_iron", text: "Estrai Ferro", class: "action-button", hoverText: "Usa due lavoratori per estrarre 10 ferro.", actions: [{ type: "removeResource", resource: "workers", amount: 2 }, { type: "addResource", resource: "iron", amount: 10 }, { type: "showMessage", title: "Ferro Estratto", message: "Hai estratto 10 ferro." }] },
                    { id: "mine_sell", text: "Vendi Minerali", class: "action-button success", hoverText: "Vendi 20 carbone e 10 ferro per 80 scellini.", actions: [{ type: "removeResource", resource: "coal", amount: 20 }, { type: "removeResource", resource: "iron", amount: 10 }, { type: "addResource", resource: "shillings", amount: 80 }, { type: "showMessage", title: "Minerali Venduti", message: "Hai venduto carbone e ferro per 80 scellini." }] }
                ]
            },
            "location_5": {
                id: "location_5",
                title: "Torbiera",
                image: "locations/healing_spring.jpg",
                guideText: "Una vasta e umida torbiera. La torba è un combustibile essenziale.",
                buttons: [
                    { id: "peat_cut", text: "Taglia Torba", class: "action-button", hoverText: "Usa un lavoratore per tagliare 40 torba.", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "peat", amount: 40 }, { type: "showMessage", title: "Torba Tagliata", message: "Hai raccolto 40 torba." }] },
                    { id: "peat_sell", text: "Vendi Torba", class: "action-button success", hoverText: "Vendi 40 torba per 20 scellini.", actions: [{ type: "removeResource", resource: "peat", amount: 40 }, { type: "addResource", resource: "shillings", amount: 20 }, { type: "showMessage", title: "Torba Venduta", message: "Hai venduto 40 torba per 20 scellini." }] },
                    { id: "peat_event", text: "Pioggia", class: "action-button danger", hoverText: "La pioggia torrenziale rovina parte del lavoro.", actions: [{ type: "removeResource", resource: "peat", amount: 10, check: false }, { type: "showMessage", title: "Pioggia!", message: "La pioggia ha rovinato 10 unità di torba." }] }
                ]
            },
            "location_6": {
                id: "location_6",
                title: "Villaggio di Pescatori",
                image: "locations/exotic_bazaar.jpg",
                guideText: "Un piccolo villaggio sulla costa. L'aria odora di sale e pesce fresco.",
                buttons: [
                    { id: "fish_catch", text: "Pesca", class: "action-button", hoverText: "Manda un lavoratore a pescare. (+30 Pesce)", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "fish", amount: 30 }, { type: "showMessage", title: "Pesca Abbondante", message: "Hai pescato 30 pesci." }] },
                    { id: "fish_sell", text: "Vendi Pesce", class: "action-button success", hoverText: "Vendi 30 pesce per 20 scellini.", actions: [{ type: "removeResource", resource: "fish", amount: 30 }, { type: "addResource", resource: "shillings", amount: 20 }, { type: "showMessage", title: "Pesce Venduto", message: "Hai venduto il pesce per 20 scellini." }] },
                    { id: "fish_event", text: "Tempesta", class: "action-button danger", hoverText: "Una tempesta improvvisa impedisce di uscire in mare.", actions: [{ type: "showMessage", title: "Tempesta!", message: "Nessuno può pescare oggi." }] }
                ]
            },
            "location_7": {
                id: "location_7",
                title: "Pascolo delle Pecore",
                image: "locations/stone_quarry.jpg",
                guideText: "Un vasto pascolo dove le pecore brucano l'erba. Qui si produce la lana.",
                buttons: [
                    { id: "wool_shear", text: "Tosa le Pecore", class: "action-button", hoverText: "Usa un lavoratore per tosare le pecore. (+20 Lana)", actions: [{ type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "wool", amount: 20 }, { type: "showMessage", title: "Lana Raccolta", message: "Hai prodotto 20 unità di lana." }] },
                    { id: "wool_sell", text: "Vendi Lana", class: "action-button success", hoverText: "Vendi 20 lana per 30 scellini.", actions: [{ type: "removeResource", resource: "wool", amount: 20 }, { type: "addResource", resource: "shillings", amount: 30 }, { type: "showMessage", title: "Lana Venduta", message: "Hai venduto la lana per 30 scellini." }] },
                    { id: "wool_event", text: "Fuga di Pecore", class: "action-button danger", hoverText: "Alcune pecore sono scappate dal recinto.", actions: [{ type: "showMessage", title: "Pecore in Fuga!", message: "Perdi tempo a recuperarle.", imageUrl: "img/fuga_pecore.jpg" }] }
                ]
            },
            "location_8": {
                id: "location_8",
                title: "Distilleria",
                image: "locations/alchemist_lab.jpg",
                guideText: "La distilleria locale. Qui il grano e la torba diventano oro liquido: il whisky.",
                buttons: [
                    { id: "distill_whisky", text: "Produci Whisky", class: "action-button", hoverText: "Usa grano, torba e un lavoratore per produrre 5 whisky.", actions: [{ type: "removeResource", resource: "grain", amount: 20 }, { type: "removeResource", resource: "peat", amount: 10 }, { type: "removeResource", resource: "workers", amount: 1 }, { type: "addResource", resource: "whisky", amount: 5 }, { type: "showMessage", title: "Whisky Prodotto", message: "Hai prodotto 5 unità di whisky." }] },
                    { id: "distill_sell", text: "Vendi Whisky", class: "action-button success", hoverText: "Vendi 5 whisky per 100 scellini.", actions: [{ type: "removeResource", resource: "whisky", amount: 5 }, { type: "addResource", resource: "shillings", amount: 100 }, { type: "showMessage", title: "Whisky Venduto", message: "Hai venduto il whisky per 100 scellini!" }] },
                    { id: "distill_taste", text: "Controllo Qualità", class: "action-button", hoverText: "Assaggia il prodotto per assicurarti che sia perfetto.", actions: [{ type: "removeResource", resource: "whisky", amount: 1 }, { type: "showMessage", title: "Salute!", message: "Un sorso per la scienza!" }] }
                ]
            },
            "location_9": {
                id: "location_9",
                title: "Porto",
                image: "locations/jeweler_district.jpg",
                guideText: "Il porto commerciale. Esporta grandi quantità di merci per un grande profitto.",
                buttons: [
                    { id: "port_export_lumber", text: "Esporta Legname", class: "action-button success", hoverText: "Esporta 50 legname e 20 ferro per 150 scellini.", actions: [{ type: "removeResource", resource: "lumber", amount: 50 }, { type: "removeResource", resource: "iron", amount: 20 }, { type: "addResource", resource: "shillings", amount: 150 }, { type: "showMessage", title: "Esportazione Riuscita", message: "Hai guadagnato 150 scellini." }] },
                    { id: "port_export_farm", text: "Esporta Prodotti Agricoli", class: "action-button success", hoverText: "Esporta 50 grano, 50 avena e 20 lana per 120 scellini.", actions: [{ type: "removeResource", resource: "grain", amount: 50 }, { type: "removeResource", resource: "oats", amount: 50 }, { type: "removeResource", resource: "wool", amount: 20 }, { type: "addResource", resource: "shillings", amount: 120 }, { type: "showMessage", title: "Esportazione Riuscita", message: "Hai guadagnato 120 scellini." }] },
                    { id: "port_export_fuel", text: "Esporta Combustibili", class: "action-button success", hoverText: "Esporta 50 pesce e 50 carbone per 100 scellini.", actions: [{ type: "removeResource", resource: "fish", amount: 50 }, { type: "removeResource", resource: "coal", amount: 50 }, { type: "addResource", resource: "shillings", amount: 100 }, { type: "showMessage", title: "Esportazione Riuscita", message: "Hai guadagnato 100 scellini." }] }
                ]
            },
            "location_10": {
                id: "location_10",
                title: "Città",
                image: "locations/main_menu_bg.png",
                guideText: "Il centro della città. Qui si trovano il pub e gli uffici.",
                buttons: [
                    { id: "town_taxes", text: "Paga Tasse", class: "action-button danger", hoverText: "Paga 20 scellini di tasse.", actions: [{ type: "removeResource", resource: "shillings", amount: 20 }, { type: "showMessage", title: "Tasse Pagate", message: "Hai pagato 20 scellini di tasse." }] },
                    { id: "town_pub", text: "Visita il Pub", class: "action-button", hoverText: "Spendi 5 scellini per una birra e quattro chiacchiere.", actions: [{ type: "removeResource", resource: "shillings", amount: 5 }, { type: "showMessage", title: "Al Pub", message: "Ti sei preso una pausa." }] },
                    { id: "town_rest", text: "Riposa", class: "action-button", hoverText: "Passi la notte in locanda per recuperare le energie.", actions: [{ type: "showMessage", title: "Ben Riposato", message: "I tuoi lavoratori sono più produttivi." }] }
                ]
            }
        };
        
        // Database per le cutscene di fine anno e finali
        const yearEndCutscenes = {
            1: { title: "Fine del Primo Anno", narrative: "Un anno è passato. Le stagioni sono cambiate, ma la tua determinazione è più forte che mai. Nuove sfide ti attendono.", image: "img/placeholder_year1.png" },
            2: { title: "Fine del Secondo Anno", narrative: "Due anni di fatiche e successi. La tua fama inizia a crescere. Cosa ti riserverà il futuro?", image: "img/placeholder_year2.png" },
            3: { title: "Fine del Terzo Anno", narrative: "Tre anni. Sei un veterano ormai. Le tue decisioni hanno plasmato questa terra.", image: "img/placeholder_year3.png" },
            4: { title: "Fine del Quarto Anno", narrative: "Quattro anni. Il mondo intorno a te è cambiato, e tu con esso.", image: "img/placeholder_year4.png" },
            5: { title: "Fine del Quinto Anno", narrative: "Cinque anni. Metà del tuo viaggio è compiuta. Guarda indietro con orgoglio e avanti con speranza.", image: "img/placeholder_year5.png" },
            6: { title: "Fine del Sesto Anno", narrative: "Sei anni. Le difficoltà ti hanno reso più forte. La fine non è lontana.", image: "img/placeholder_year6.png" },
            7: { title: "Fine del Settimo Anno", narrative: "Sette anni. I semi che hai piantato stanno dando i loro frutti.", image: "img/placeholder_year7.png" },
            8: { title: "Fine dell'Ottavo Anno", narrative: "Otto anni. La leggenda del tuo nome si diffonde in lungo e in largo.", image: "img/placeholder_year8.png" },
            9: { title: "Fine del Nono Anno", narrative: "Nove anni. L'ultimo anno ti attende. Prepara le tue forze per lo sprint finale.", image: "img/placeholder_year9.png" },
        };

        const finalCutscenes = {
            "shillings": { title: "Finale: Il Magnate", narrative: "Hai accumulato ricchezze inimmaginabili. Il tuo nome è sussurrato nelle sale del potere e i tuoi scellini possono comprare regni. La tua eredità è un impero finanziario.", image: "img/ending_rich.png" },
            "cows": { title: "Finale: Il Re Mandriano", narrative: "Le tue mandrie sono le più grandi che si siano mai viste. Controlli il mercato del bestiame e la tua influenza si estende su ogni pascolo. La tua eredità è legata alla terra.", image: "img/ending_cows.png" },
            "workers": { title: "Finale: Il Leader del Popolo", narrative: "Hai radunato una forza lavoro leale e potente. Le tue gilde e i tuoi lavoratori sono il cuore pulsante della nazione. La tua eredità è una società prospera.", image: "img/ending_workers.png" },
            "default": { title: "Finale: L'Avventuriero", narrative: "Hai vissuto una vita piena di avventure, senza eccellere in un campo specifico ma lasciando il segno ovunque. La tua eredità è una storia che verrà raccontata per generazioni.", image: "img/ending_default.png" }
        };

        // Variabile globale che tiene traccia dell'ID della location in cui si trova attualmente il giocatore.
        let currentGameLocationId = null; // Verrà impostato all'avvio
        

        /**
         * Avvia la sequenza di eventi per la fine di un anno (anni 1-9).
         */
        function startEndOfYearSequence() {
            const currentYear = Player.get('gameData.currentYear');

            Player.set('gameData.currentYear', currentYear + 1);
            Player.set('gameData.currentBoardPosition', 0);
            Player.saveData(true);

            const cutscene = yearEndCutscenes[currentYear];

            if (cutscene) {
                showSection('cutscene-section');

                const titleElement = document.getElementById('cutscene-title');
                titleElement.textContent = cutscene.title.toUpperCase();
                titleElement.setAttribute('data-text', cutscene.title.toUpperCase());
                document.getElementById('cutscene-narrative-content').innerHTML = cutscene.narrative.replace(/\n/g, '<br><br>');
                const imageContainer = document.querySelector('#cutscene-section .image-container');
                imageContainer.innerHTML = `<img src="${cutscene.image}" alt="${cutscene.title}">`;

                const continueButton = document.querySelector('#cutscene-section .continue-button');
                continueButton.onclick = () => {
                    // Azione per tornare al gioco
                    showSection('game-ui-section');
                    initializeGameUI();

                    // Ripristina il gestore di eventi originale per le cutscene standard
                    continueButton.onclick = continueCutscene;
                };
            } else {
                console.error(`Cutscene di fine anno non trovata per l'anno ${currentYear}`);
                showSection('game-ui-section');
                initializeGameUI();
            }
        }

        /**
         * Determina la condizione di vittoria analizzando le risorse del giocatore.
         * @returns {string} La risorsa che determina il finale ('shillings', 'cows', 'workers', o 'default').
         */
        function getWinningCondition() {
            const resources = Player.get('resources');
            // Definisce le risorse che concorrono alla vittoria.
            const victoryResources = {
                shillings: resources.shillings || 0,
                cows: resources.cows || 0,
                workers: resources.workers || 0
            };

            let maxAmount = -1;
            let winningResource = 'default';

            for (const resource in victoryResources) {
                if (victoryResources[resource] > maxAmount) {
                    maxAmount = victoryResources[resource];
                    winningResource = resource;
                }
            }

            // Per evitare una vittoria con un punteggio basso, si può impostare una soglia minima.
            if (maxAmount < 10) {
                return 'default';
            }

            return winningResource;
        }

        /**
         * Avvia la sequenza di vittoria finale (anno 10).
         */
        function startFinalVictorySequence() {
            console.log("🏆 Avvio sequenza di vittoria finale...");

            const winningCondition = getWinningCondition();
            const cutscene = finalCutscenes[winningCondition] || finalCutscenes['default'];

            // Mostra la sezione cutscene
            showSection('cutscene-section');

            // Carica i dati della cutscene finale
            const titleElement = document.getElementById('cutscene-title');
            titleElement.textContent = cutscene.title.toUpperCase();
            titleElement.setAttribute('data-text', cutscene.title.toUpperCase());
            document.getElementById('cutscene-narrative-content').innerHTML = cutscene.narrative.replace(/\n/g, '<br><br>');
            const imageContainer = document.querySelector('#cutscene-section .image-container');
            imageContainer.innerHTML = `<img src="${cutscene.image}" alt="${cutscene.title}">`;

            // Modifica il pulsante "Continua" per tornare al menu principale
            const continueButton = document.querySelector('#cutscene-section .continue-button');
            continueButton.textContent = "FINE"; // Cambia il testo del pulsante
            continueButton.onclick = () => {
                // Azione per tornare al menu principale
                showSection('main-menu-section');

                // Ripristina il testo e l'onclick originali del pulsante per usi futuri
                continueButton.textContent = "CONTINUA";
                continueButton.onclick = continueCutscene;
            };
        }

        /**
         * Funzione di utilità per disabilitare tutti i pulsanti di azione tranne il pulsante "MUOVITI".
         * Questo forza il giocatore a muoversi dopo aver completato un'azione.
         */
        function enableMoveAndDisableActions() {
            const actionButtons = document.querySelectorAll('.buttons-section .action-button');
            actionButtons.forEach(button => {
                if (button.id === 'btn_move') {
                    button.disabled = false; // Abilita il pulsante "MUOVITI".
                } else {
                    button.disabled = true; // Disabilita tutti gli altri.
                }
            });
            console.log('🔒 Azioni bloccate, 🔑 movimento sbloccato.');
        }

        // --- SISTEMA DI AZIONI ---

        /**
         * Classe che gestisce l'esecuzione delle azioni definite nei pulsanti delle location.
         */
        class GameActionSystem {
            /**
             * Esegue una sequenza di azioni.
             * @param {object[]} actions - Un array di oggetti azione.
             */
            static executeActions(actions) {
                console.log('🎮 Eseguendo azioni:', actions);

                // Fase 1: Controlla se il giocatore ha abbastanza risorse per TUTTE le azioni di tipo 'removeResource'.
                for (const action of actions) {
                    if (action.type === 'removeResource') {
                        if (Player.get(`resources.${action.resource}`) < action.amount) {
                            // Se anche una sola risorsa è insufficiente, mostra un messaggio e interrompe tutto.
                            showInfoModal("RISORSE INSUFFICIENTI", `Non hai abbastanza ${action.resource} per completare questa azione.`);
                            return;
                        }
                    }
                }
                
                // Variabile per memorizzare un'eventuale azione 'showMessage', da mostrare alla fine.
                let showMessageAction = null;
                
                // Fase 2: Se tutti i controlli sulle risorse sono passati, esegue le azioni.
                for (const action of actions) {
                    switch (action.type) {
                        case "addResource":
                            Player.addResource(action.resource, action.amount);
                            break;
                            
                        case "addExperience":
                            Player.addExperience(action.amount);
                            break;
                            
                        case "removeResource":
                            Player.removeResource(action.resource, action.amount);
                            break;

                        case "showMessage":
                            // Non mostra subito il messaggio, ma lo salva per dopo.
                            showMessageAction = action;
                            break;
                            
                        case "addItem":
                            Player.addItem(action.itemId, action.quantity || 1);
                            break;
                            
                        case "removeItem":
                            Player.removeItem(action.itemId, action.quantity || 1);
                            break;
                            
                        case "setFlag":
                            Player.set(`gameData.gameFlags.${action.flag}`, action.value);
                            break;
                            
                        default:
                            console.warn('⚠️ Azione sconosciuta:', action.type);
                    }
                }
                
                // Aggiorna la visualizzazione delle risorse nell'UI.
                updateResourcesDisplay();
                updateStatsBox();
                
                // Fase 3: Se c'era un'azione 'showMessage', la esegue ora.
                if (showMessageAction) {
                    // Crea una nuova callback che, dopo quella originale, abilita il movimento.
                    const originalCallback = showMessageAction.onContinue;
                    const newCallback = () => {
                        if (originalCallback) originalCallback();
                        enableMoveAndDisableActions();
                    };
                    showInfoModal(
                        showMessageAction.title,
                        showMessageAction.message,
                        newCallback, // Usa la nuova callback.
                        'info',
                        showMessageAction.imageUrl || null
                    );
                } else {
                    // Se non c'è nessun messaggio da mostrare, abilita subito il movimento.
                    enableMoveAndDisableActions();
                }
            }

        }
        
        // --- GESTIONE LOCATION E UI ---

        /**
         * Carica dinamicamente una location nell'interfaccia di gioco.
         * @param {string} locationId - L'ID della location da caricare.
         */
        function loadGameLocation(locationId) {
            const location = gameLocations[locationId];
            if (!location) {
                console.error('❌ Location non trovata:', locationId);
                return false;
            }
            
            // Aggiorna titolo, immagine e testo guida della location.
            const titleElement = document.getElementById('game-ui-title');
            if (titleElement) {
                titleElement.textContent = location.title.toUpperCase();
                titleElement.setAttribute('data-text', location.title.toUpperCase());
            }
            
            const imageContainer = document.querySelector('.image-container-game');
            if (imageContainer) {
                imageContainer.innerHTML = `<img src="${location.image}" alt="${location.title}">`;
            }
            
            currentLocationBaseText = location.guideText;
            changeNarrativeText('base');
            
            // Aggiorna i pulsanti di azione disponibili.
            updateGameButtons(location.buttons);
            
            return true;
        }
        
        /**
         * Pulisce e ricrea i pulsanti di azione nella UI in base ai dati della location corrente.
         * @param {object[]} buttons - L'array di oggetti pulsante dalla location.
         */
        function updateGameButtons(buttons) {
            const buttonsSection = document.querySelector('.buttons-section');
            if (!buttonsSection) return;
            
            buttonsSection.innerHTML = ''; // Svuota i pulsanti precedenti.
            
            // Crea un pulsante per ogni azione definita nella location.
            buttons.forEach((buttonData) => {
                const button = document.createElement('button');
                button.id = buttonData.id;
                button.className = buttonData.class + " action-button";
                button.textContent = buttonData.text;
                
                button.addEventListener('click', () => GameActionSystem.executeActions(buttonData.actions));
                button.addEventListener('mouseenter', () => changeNarrativeText('custom', buttonData.hoverText));
                button.addEventListener('mouseleave', () => changeNarrativeText('base'));
                
                buttonsSection.appendChild(button);
            });

            // Aggiunge sempre il pulsante "MUOVITI" alla fine.
            const moveButton = document.createElement('button');
            moveButton.id = 'btn_move';
            moveButton.className = 'action-button';
            moveButton.textContent = 'MUOVITI';
            moveButton.addEventListener('click', handleMove);
            moveButton.addEventListener('mouseenter', () => changeNarrativeText('custom', "Avanza sul tabellone di 1-6 caselle."));
            moveButton.addEventListener('mouseleave', () => changeNarrativeText('base'));
            buttonsSection.appendChild(moveButton);
        }
        
        // Variabile per memorizzare il testo di guida base della location corrente.
        let currentLocationBaseText = "Caricamento...";

        // --- LOGICA DI MOVIMENTO ---

        /**
         * Genera un numero intero casuale crittograficamente sicuro tra min e max (inclusi).
         */
        function getRandomInt(min, max) {
            const randomBuffer = new Uint32Array(1);
            window.crypto.getRandomValues(randomBuffer);
            let randomNumber = randomBuffer[0] / (0xffffffff + 1);
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(randomNumber * (max - min + 1)) + min;
        }
        
        /**
         * Gestisce l'azione di movimento del giocatore.
         */
        function handleMove() {
            const roll = getRandomInt(1, 6); // Tira un dado a 6 facce.

            // Mostra il risultato del tiro in un modale.
            showInfoModal("MOVIMENTO", `Hai tirato un ${roll}! Avanzi di ${roll} caselle.`, () => {
                // Questa callback viene eseguita DOPO che l'utente chiude il modale.
                let currentPosition = Player.get('gameData.currentBoardPosition');
                let newPosition = currentPosition + roll;

                // Se si supera la fine del tabellone, gestisce la fine dell'anno/gioco.
                if (newPosition >= gameBoard.length) {
                    handleBoardCompletion();
                } else {
                    // Altrimenti, si muove normalmente.
                    Player.set('gameData.currentBoardPosition', newPosition);
                    Player.saveData(true); // Forza salvataggio
                    const newLocationId = gameBoard[newPosition];
                    loadGameLocation(newLocationId);
                }
            });
        }

        /**
         * Gestisce il completamento del tabellone.
         * Controlla l'anno corrente per decidere se avviare la sequenza di fine anno o la vittoria finale.
         * Le funzioni startEndOfYearSequence e startFinalVictorySequence verranno implementate nei prossimi passaggi.
         */
        function handleBoardCompletion() {
            const currentYear = Player.get('gameData.currentYear');

            if (currentYear >= 10) {
                startFinalVictorySequence();
            } else {
                startEndOfYearSequence();
            }
        }

        // Oggetto che contiene i testi per il pannello narrativo.
        const narrativeTexts = {
            base: () => currentLocationBaseText,
            backMenu: "Torna al menu principale. I progressi vengono salvati automaticamente.",
            volume: "Regola il volume del gioco.",
            custom: null
        };

        // --- FUNZIONI DI GESTIONE DELL'INTERFACCIA DI GIOCO (GAME UI) ---

        /**
         * Inizializza l'interfaccia di gioco.
         * Questa funzione viene chiamata quando si entra nella sezione di gioco (es. caricando una partita).
         */
        function initializeGameUI() {
            console.log('🎮 Inizializzando Game UI...');
            
            // Carica la location corretta in base alla posizione salvata del giocatore sul tabellone.
            const boardPosition = Player.get('gameData.currentBoardPosition');
            currentGameLocationId = gameBoard[boardPosition];
            
            // Carica i dati della location (titolo, immagine, pulsanti, etc.).
            loadGameLocation(currentGameLocationId);
            
            // Aggiorna la visualizzazione di tutte le risorse del giocatore.
            updateResourcesDisplay();
            updateStatsBox();
            
            // Imposta lo stato iniziale del controllo del volume in base ai dati salvati.
            const slider = document.getElementById('volume-slider');
            if (slider) {
                slider.value = Player.get('settings.audio_volume');
                updateVolumeIcon();
                updateVolumeSlider();
            }
            
            // Attiva gli event listener per gli elementi del footer (es. hover text).
            setupGameUIFooterEventListeners();
            
            console.log('✅ Game UI inizializzato con location:', currentGameLocationId);
        }

        /**
         * Cambia il testo mostrato nel pannello narrativo della UI di gioco.
         * @param {string} textKey - La chiave del testo da mostrare (es. 'base', 'custom', 'volume').
         * @param {string|null} customText - Un testo personalizzato da mostrare se textKey è 'custom'.
         */
        function changeNarrativeText(textKey, customText = null) {
            const narrativeContent = document.getElementById('game-narrative-content');
            if (!narrativeContent) return; // Esce se l'elemento non esiste.
            
            let textToShow = "";
            
            // Determina quale testo mostrare.
            if (textKey === 'custom' && customText) {
                textToShow = customText; // Testo personalizzato (es. hover di un pulsante).
            } else if (textKey === 'base') {
                // Testo base della location corrente.
                textToShow = typeof narrativeTexts.base === 'function' ? narrativeTexts.base() : narrativeTexts.base;
            } else if (narrativeTexts[textKey]) {
                // Altri testi predefiniti (es. per il volume).
                textToShow = narrativeTexts[textKey];
            } else {
                // Fallback al testo base se la chiave non è valida.
                textToShow = currentLocationBaseText;
            }
            
            // Imposta il testo nell'elemento HTML.
            narrativeContent.textContent = textToShow;
        }

        /**
         * Funzione helper per ripristinare il testo narrativo al suo valore di base (la guida della location).
         */
        function resetNarrativeText() {
            changeNarrativeText('base');
        }

        // Funzioni obsolete, mantenute per non rompere eventuali vecchi riferimenti.
        // La logica dei pulsanti è ora gestita dinamicamente da 'updateGameButtons' e 'GameActionSystem'.
        function actionButton1() { console.log('⚠️ actionButton1 chiamata - ora gestita dinamicamente'); }
        function actionButton2() { console.log('⚠️ actionButton2 chiamata - ora gestita dinamicamente'); }
        function actionButton3() { console.log('⚠️ actionButton3 chiamata - ora gestita dinamicamente'); }

        /**
         * Aggiorna la visualizzazione di tutte le risorse del giocatore nell'interfaccia.
         * Prende i valori dal sistema PlayerData e li scrive negli elementi HTML corrispondenti.
         */
        function updateResourcesDisplay() {
            // Seleziona ogni elemento per il valore della risorsa.
            const shillingsElement = document.getElementById('shillings-value');
            const workersElement = document.getElementById('workers-value');
            const woolElement = document.getElementById('wool-value');
            const whiskyElement = document.getElementById('whisky-value');
            const peatElement = document.getElementById('peat-value');
            const coalElement = document.getElementById('coal-value');
            const ironElement = document.getElementById('iron-value');
            const fishElement = document.getElementById('fish-value');
            const lumberElement = document.getElementById('lumber-value');
            const oatsElement = document.getElementById('oats-value');
            const grainElement = document.getElementById('grain-value');
            const cowsElement = document.getElementById('cows-value');
            const clothElement = document.getElementById('cloth-value');
            const toolsElement = document.getElementById('tools-value');
            const stoneElement = document.getElementById('stone-value');
            const potteryElement = document.getElementById('pottery-value');

            // Aggiorna il testo di ogni elemento, se esiste.
            // Usa '|| 0' come fallback se il valore non è definito.
            // toLocaleString() formatta i numeri con i separatori delle migliaia (es. 1,000).
            if (shillingsElement) shillingsElement.textContent = (Player.get('resources.shillings') || 0).toLocaleString();
            if (workersElement) workersElement.textContent = (Player.get('resources.workers') || 0).toLocaleString();
            if (woolElement) woolElement.textContent = (Player.get('resources.wool') || 0).toLocaleString();
            if (whiskyElement) whiskyElement.textContent = (Player.get('resources.whisky') || 0).toLocaleString();
            if (peatElement) peatElement.textContent = (Player.get('resources.peat') || 0).toLocaleString();
            if (coalElement) coalElement.textContent = (Player.get('resources.coal') || 0).toLocaleString();
            if (ironElement) ironElement.textContent = (Player.get('resources.iron') || 0).toLocaleString();
            if (fishElement) fishElement.textContent = (Player.get('resources.fish') || 0).toLocaleString();
            if (lumberElement) lumberElement.textContent = (Player.get('resources.lumber') || 0).toLocaleString();
            if (oatsElement) oatsElement.textContent = (Player.get('resources.oats') || 0).toLocaleString();
            if (grainElement) grainElement.textContent = (Player.get('resources.grain') || 0).toLocaleString();
            if (cowsElement) cowsElement.textContent = (Player.get('resources.cows') || 0).toLocaleString();
            if (clothElement) clothElement.textContent = (Player.get('resources.cloth') || 0).toLocaleString();
            if (toolsElement) toolsElement.textContent = (Player.get('resources.tools') || 0).toLocaleString();
            if (stoneElement) stoneElement.textContent = (Player.get('resources.stone') || 0).toLocaleString();
            if (potteryElement) potteryElement.textContent = (Player.get('resources.pottery') || 0).toLocaleString();
        }

        /**
         * Aggiorna il box delle statistiche (anni passati e punteggio).
         */
        function updateStatsBox() {
            const yearsPassedElement = document.getElementById('years-passed-value');
            const scoreElement = document.getElementById('score-value');

            if (yearsPassedElement) {
                // L'anno di gioco inizia da 1, quindi gli anni passati sono currentYear - 1.
                yearsPassedElement.textContent = (Player.get('gameData.currentYear') || 1) - 1;
            }
            if (scoreElement) {
                // Usa gli scellini come punteggio.
                scoreElement.textContent = (Player.get('resources.shillings') || 0).toLocaleString();
            }
        }

        /**
         * Funzione obsoleta. Il salvataggio è ora gestito automaticamente dalla classe PlayerDataManager.
         */
        function savePlayerData() {
            return Player.saveData(true);
        }

        // ================= FUNZIONI DI CONTROLLO DEL VOLUME E FOOTER =================
        
        /**
         * Aggiorna l'aspetto dello slider del volume.
         * Colora la traccia dello slider in base al valore corrente e imposta la posizione del pollice.
         */
        function updateVolumeSlider() {
            const sliders = document.querySelectorAll('.volume-slider');
            sliders.forEach(slider => {
                if (slider) {
                    // Se l'audio è muto, la barra deve apparire vuota (volume 0).
                    const displayVolume = Player.get('settings.is_muted') ? 0 : Player.get('settings.audio_volume');
                    const percentage = displayVolume;

                    // Imposta una variabile CSS '--volume-percent' che viene usata nel CSS per colorare la traccia.
                    slider.style.setProperty('--volume-percent', `${percentage}%`);

                    // Aggiorna il valore effettivo dello slider, che muove il pollice.
                    slider.value = displayVolume;
                }
            });
        }

        /**
         * Aggiorna l'icona del volume (emoji) in base al livello del volume e allo stato mute.
         */
        function updateVolumeIcon() {
            const volumeIcons = document.querySelectorAll('.volume-icon');
            volumeIcons.forEach(volumeIcon => {
                if (volumeIcon) {
                    if (Player.get('settings.is_muted') || Player.get('settings.audio_volume') == 0) {
                        volumeIcon.textContent = '🔇'; // Icona per muto o volume zero.
                    } else if (Player.get('settings.audio_volume') < 30) {
                        volumeIcon.textContent = '🔈'; // Volume basso.
                    } else if (Player.get('settings.audio_volume') < 70) {
                        volumeIcon.textContent = '🔉'; // Volume medio.
                    } else {
                        volumeIcon.textContent = '🔊'; // Volume alto.
                    }
                }
            });
        }

        /**
         * Funzione chiamata quando l'utente muove lo slider del volume.
         * @param {number} value - Il nuovo valore dello slider (0-100).
         */
        function changeVolume(value) {
            // Salva il nuovo valore del volume nei dati del giocatore.
            Player.set('settings.audio_volume', parseInt(value));
            
            // Se il volume viene alzato da zero, rimuove automaticamente il mute.
            if (value > 0 && Player.get('settings.is_muted')) {
                Player.set('settings.is_muted', false);
            }
            
            // Comunica il nuovo volume all'AudioManager.
            audioManager.setVolume(parseInt(value));
            if (value > 0) {
                audioManager.toggleMute(false);
            }

            // Aggiorna l'interfaccia grafica (slider e icona).
            updateVolumeSlider();
            updateVolumeIcon();
        }

        /**
         * Funzione chiamata quando si clicca sull'icona del volume.
         * Attiva o disattiva il mute.
         */
        function toggleMute() {
            // Inverte il valore booleano di 'is_muted'.
            const isMuted = !Player.get('settings.is_muted');
            Player.set('settings.is_muted', isMuted);
            
            // Comunica lo stato mute all'AudioManager.
            audioManager.toggleMute(isMuted);

            // Aggiorna l'interfaccia.
            updateVolumeIcon();
            updateVolumeSlider();
        }

        /**
         * Gestisce il ritorno al menu principale dalla schermata di gioco.
         * Chiede conferma all'utente.
         */
        function backToMainMenu() {
            showConfirmModal(
                "RITORNA AL MENU",
                "Sei sicuro di voler tornare al menu principale?\n\nI progressi verranno salvati automaticamente.",
                function() {
                    Player.saveData(true); // Forza un salvataggio prima di uscire.
                    showSection('main-menu-section');
                }
            );
        }

        /**
         * Imposta gli event listener per gli elementi del footer della UI di gioco.
         * Questo viene fatto una sola volta quando la UI viene inizializzata.
         */
        function setupGameUIFooterEventListeners() {
            const backButton = document.querySelector('.back-button');
            const volumeControl = document.querySelector('.volume-control');
            
            // Aggiunge gli listener per mostrare il testo di aiuto nel pannello narrativo.
            if (backButton) {
                backButton.addEventListener('mouseenter', () => changeNarrativeText('backMenu'));
                backButton.addEventListener('mouseleave', resetNarrativeText);
            }
            if (volumeControl) {
                volumeControl.addEventListener('mouseenter', () => changeNarrativeText('volume'));
                volumeControl.addEventListener('mouseleave', resetNarrativeText);
            }
        }

        // ================= GLOBAL EVENT LISTENERS =================
        
        // La gestione tastiera è ora integrata nel modal system sopra

        // ================= INITIALIZATION =================
        
        // Inizializzazione
        window.addEventListener('load', function() {
            // Inizializza con il main menu
            showSection('main-menu-section');
            console.log('🎮 Gioco inizializzato - Menu principale attivo');

            // Avvia la musica di sottofondo
            // NOTA: Aggiungi qui altri file .mp3 se necessario
            const musicFiles = ['audio/placeholder.mp3'];
            audioManager.playBackgroundMusic(musicFiles);
        });

        // Gestione ridimensionamento finestra
        window.addEventListener('resize', function() {
            // Il CSS si occupa automaticamente del ridimensionamento
            // Qui potresti aggiungere logica aggiuntiva se necessaria
        });

        // La simulazione di aggiornamento risorse in tempo reale è stata rimossa.
        
        // ================= SISTEMA DI IMPORT/EXPORT SALVATAGGI =================
        
        /**
         * Crea e avvia il download di un file JSON contenente i dati di salvataggio del giocatore.
         */
        function downloadSavegame() {
            try {
                // Crea un oggetto contenitore per il salvataggio, aggiungendo metadati utili.
                const savegameData = {
                    gameTitle: "Game SPA Adventure",
                    exportDate: new Date().toISOString(),
                    exportedBy: Player.get('profile.playerName') || 'Unknown Player',
                    gameVersion: Player.get('meta.version'),
                    playerData: Player.data // L'oggetto completo dei dati del giocatore.
                };
                
                // Converte l'oggetto in una stringa JSON ben formattata (con indentazione).
                const jsonString = JSON.stringify(savegameData, null, 2);
                // Crea un "Blob", che è un oggetto simile a un file, con il contenuto JSON.
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                // Crea un nome di file dinamico e descrittivo.
                const playerName = (Player.get('profile.playerName') || 'player').replace(/[^a-zA-Z0-9]/g, '_');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const filename = `savegame_${playerName}_${timestamp}.json`;
                
                // Trucco per avviare il download programmaticamente:
                // 1. Crea un link <a> invisibile.
                const url = URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = filename; // Questo attributo dice al browser di scaricare il file con questo nome.
                
                // 2. Aggiunge il link al documento, lo clicca e lo rimuove subito dopo.
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // 3. Rilascia l'URL dell'oggetto per liberare memoria.
                URL.revokeObjectURL(url);
                
                showInfoModal("DOWNLOAD COMPLETATO", `Savegame scaricato con successo!\nFile: ${filename}`, null, 'download');
                
            } catch (error) {
                console.error('❌ Errore durante il download del savegame:', error);
                showInfoModal("ERRORE DOWNLOAD", "Si è verificato un errore durante il download.");
            }
        }
        
        /**
         * Gestisce l'evento di caricamento di un file di salvataggio dall'input file.
         * @param {Event} event - L'evento 'change' dell'input file.
         */
        function handleSavegameFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return; // Nessun file selezionato.
            
            // Legge il contenuto del file come testo.
            const reader = new FileReader();
            
            // La funzione da eseguire quando la lettura è completata.
            reader.onload = function(e) {
                try {
                    const jsonContent = e.target.result;
                    const savegameData = JSON.parse(jsonContent);
                    
                    // Valida la struttura del file JSON.
                    if (!validateSavegameFile(savegameData)) {
                        showInfoModal("FILE CORROTTO", "File di salvataggio non valido o corrotto.");
                        return;
                    }
                    
                    // Mostra un modale di conferma con i dettagli del salvataggio prima di importare.
                    const playerName = savegameData.playerData?.profile?.playerName || 'Sconosciuto';
                    const level = savegameData.playerData?.profile?.level || 0;
                    const confirmMessage = `Vuoi importare il salvataggio per ${playerName} (Liv. ${level})?\n\nATTENZIONE: Questo sovrascriverà i tuoi progressi attuali!`;
                    
                    showConfirmModal(
                        "CONFERMA IMPORTAZIONE",
                        confirmMessage,
                        () => {
                            // Se l'utente conferma, chiama la funzione di importazione.
                            importSavegame(savegameData);
                        }
                    );
                    
                } catch (error) {
                    showInfoModal("ERRORE LETTURA", "Impossibile leggere il file. Assicurati che sia un JSON valido.");
                }
            };
            
            // Inizia la lettura del file.
            reader.readAsText(file);
            
            // Resetta il valore dell'input per permettere di ricaricare lo stesso file.
            event.target.value = '';
        }
        
        /**
         * Controlla se l'oggetto di salvataggio ha la struttura di base richiesta.
         * @param {object} savegameData - L'oggetto di salvataggio letto dal file.
         * @returns {boolean} - true se il file è valido, altrimenti false.
         */
        function validateSavegameFile(savegameData) {
            // Controlli molto basilari: verifica che le chiavi principali esistano.
            return savegameData && savegameData.playerData && savegameData.playerData.meta && savegameData.playerData.profile && savegameData.playerData.resources;
        }
        
        /**
         * Importa i dati da un oggetto di salvataggio e aggiorna lo stato del gioco.
         * @param {object} savegameData - L'oggetto di salvataggio valido.
         */
        function importSavegame(savegameData) {
            try {
                // Ferma l'auto-save per evitare conflitti durante l'importazione.
                Player.stopAutoSave();
                
                // Importa i dati usando il metodo della classe PlayerDataManager.
                const success = Player.importSave(JSON.stringify(savegameData.playerData));
                
                if (success) {
                    // Se l'importazione va a buon fine, riavvia l'auto-save.
                    Player.startAutoSave();
                    
                    // Aggiorna l'interfaccia se il giocatore è nella schermata di gioco.
                    if (currentSection === 'game-ui-section') {
                        initializeGameUI(); // Re-inizializza la UI con i nuovi dati.
                    }
                    
                    showInfoModal( "IMPORTAZIONE COMPLETATA", "Salvataggio importato con successo!", null, 'success');
                } else {
                    throw new Error('Fallimento importazione dati nel PlayerDataManager.');
                }
                
            } catch (error) {
                console.error('❌ Errore critico durante l\'importazione:', error);
                showInfoModal("ERRORE IMPORTAZIONE", "Si è verificato un errore critico durante l'importazione.");
                // Riavvia l'auto-save anche in caso di errore.
                Player.startAutoSave();
            }
        }
        
        // ================= STRUMENTI PER SVILUPPATORI (DEV TOOLS) =================
        
        // Aggiunge un oggetto 'gameDevTools' all'oggetto 'window' globale.
        // Questo permette di chiamare queste funzioni direttamente dalla console del browser per test e debug.
        // Esempio: nella console, si può scrivere `gameDevTools.addResource('shillings', 1000)` per darsi 1000 scellini.
        window.gameDevTools = {
            // Aggiunge una risorsa specifica e aggiorna l'UI.
            addResource: (resource, amount) => {
                Player.addResource(resource, amount);
                updateResourcesDisplay();
                console.log(`💰 Aggiunti ${amount} ${resource}`);
            },
            
            // Mostra in console le statistiche attuali del giocatore.
            showStats: () => {
                console.log('📊 STATISTICHE GIOCATORE:', Player.data);
            },
            
            // Esporta i dati di salvataggio in console.
            exportSave: () => {
                console.log('📤 DATI ESPORTATI:', Player.exportSave());
            },
            
            // Simula il download di un salvataggio.
            downloadSave: () => {
                downloadSavegame();
            },
            
            // Resetta completamente il gioco.
            resetGame: () => {
                Player.resetGame();
            },

            // Salta a una location specifica.
            goToLocation: (locationId) => {
                if (gameLocations[locationId]) {
                    const index = gameBoard.indexOf(locationId);
                    if (index !== -1) {
                        Player.set('gameData.currentBoardPosition', index);
                        loadGameLocation(locationId);
                        console.log(`🗺️ Spostato a: ${locationId}`);
                    }
                } else {
                    console.error(`❌ Location non trovata: ${locationId}`);
                }
            },
        };
        
        // Messaggio di benvenuto per sviluppatori
        console.log(`
🎮 GAME DEV TOOLS ATTIVI - SISTEMA DINAMICO!
─────────────────────────────────────────────

🎯 SISTEMA LOCATION DINAMICO IMPLEMENTATO!
• Database JSON per location, pulsanti e azioni
• Sistema di azioni configurabile (addResource, changeLocation, etc.)
• Interfaccia completamente dinamica e data-driven
• 3 location di esempio: villaggio, foresta, rovine

📍 NUOVI COMANDI LOCATION:
• gameDevTools.listLocations() - Lista tutte le location
• gameDevTools.currentLocation() - Info location corrente
• gameDevTools.goToVillage() - Vai al villaggio
• gameDevTools.goToForest() - Vai alla foresta oscura
• gameDevTools.goToRuins() - Vai alle rovine antiche
• gameDevTools.reloadLocation() - Ricarica location
• gameDevTools.testActions() - Test azioni multiple

🔧 COMANDI CLASSICI:
• gameDevTools.addGold(1000) - Aggiungi oro
• gameDevTools.addRubies(100) - Aggiungi rubini  
• gameDevTools.addXP(50) - Aggiungi esperienza
• gameDevTools.showStats() - Mostra statistiche complete
• gameDevTools.downloadSave() - Scarica savegame

🎨 STRUTTURA DATI LOCATION:
Ogni location ha:
• id, title, image - Identificazione e visuals
• baseNarrative, guideText - Testi descrittivi
• buttons[] - Array di pulsanti dinamici con:
  ├─ text, class, hoverText - Aspetto e descrizione
  └─ actions[] - Azioni da eseguire al click

🎯 TIPI DI AZIONI SUPPORTATE:
• addResource - Modifica risorse (oro, energie, etc.)
• addExperience - Aggiunge esperienza al giocatore
• changeLocation - Cambia location di gioco
• showMessage - Mostra modale informativo
• addItem/removeItem - Gestione inventario
• setFlag - Imposta flag di gioco

🏗️ COME AGGIUNGERE NUOVE LOCATION:
1. Aggiungi entry al database gameLocations
2. Definisci buttons[] con azioni appropriate
3. Usa GameActionSystem.changeLocation() per navegare

Sistema di auto-save attivo ogni 5 secondi! 💾
Sistema di modali corretto ed exit a Google funzionante! 🌐
        `);
        
        // Log iniziale dello stato del giocatore
        setTimeout(() => {
            console.log('🎯 STATO INIZIALE GIOCATORE:');
            gameDevTools.showStats();
            console.log('\n📍 LOCATION INIZIALI DISPONIBILI:');
            gameDevTools.listLocations();
            console.log('\n🎮 Vai nel Game UI per testare il sistema dinamico!');
        }, 1000);
    </script>
</body>
</html>